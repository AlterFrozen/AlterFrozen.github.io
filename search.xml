<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《C++Primer》基础回顾 [1]</title>
    <url>/2021/12/07/C++/C++Primer-Review%5B1%5D/</url>
    <content><![CDATA[<ul>
<li>本章要是C++基础部分个人认为重要的或遗忘的细节回顾，笔记涵盖”基础知识”、“变量和基本类型”、“字符串、向量和数组”、“类型转换”</li>
<li>参考书籍《C++Primer 中文版 5th》</li>
</ul>
<span id="more"></span>

<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="I-O缓冲区（buffer）"><a href="#I-O缓冲区（buffer）" class="headerlink" title="I/O缓冲区（buffer）"></a>I/O缓冲区（buffer）</h2><ul>
<li>读写缓冲区的动作与程序中的动作是无关的（I/O与CPU），可以主动刷新输出缓冲，默认情况下读cin会刷新cout，程序非正常终止时也会刷新cout</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>输出情况</th>
</tr>
</thead>
<tbody><tr>
<td>满缓冲</td>
<td>I/O在缓冲区满后进行</td>
<td>1.缓冲区满<br>2.调用fflush<br>3.文件fclose</td>
</tr>
<tr>
<td>行缓冲</td>
<td>遇到换行符时，或者缓冲区满时，候执行实际的I/O操作</td>
<td>1.遇到换行符<br>2.缓冲区满<br>3.调用fflush<br>4.文件fclose</td>
</tr>
<tr>
<td>无缓冲</td>
<td>不缓冲，直接I/O</td>
<td>直接输出</td>
</tr>
</tbody></table>
<h2 id="stderr-amp-stdout"><a href="#stderr-amp-stdout" class="headerlink" title="stderr &amp; stdout"></a>stderr &amp; stdout</h2><h3 id="stderr（标准错误）"><a href="#stderr（标准错误）" class="headerlink" title="stderr（标准错误）"></a>stderr（标准错误）</h3><ul>
<li><strong>无缓冲</strong>，因此信息可以直接显示</li>
</ul>
<h3 id="stdout（标准输出）"><a href="#stdout（标准输出）" class="headerlink" title="stdout（标准输出）"></a>stdout（标准输出）</h3><ul>
<li><strong>行缓冲</strong>，输出字符会暂存在缓冲区，等待按下回车键才进行实际的I/O操作</li>
</ul>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><ul>
<li><strong>是一个复杂类型的名字变得简单明了、易于理解和使用</strong></li>
</ul>
<h3 id="使用关键字typedef"><a href="#使用关键字typedef" class="headerlink" title="使用关键字typedef"></a>使用关键字typedef</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> myDouble;</span><br><span class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; (<span class="built_in"><span class="keyword">typeid</span></span>(myDouble) == <span class="built_in"><span class="keyword">typeid</span></span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="使用别名声明（alias-declaration）"><a href="#使用别名声明（alias-declaration）" class="headerlink" title="使用别名声明（alias declaration）"></a>使用别名声明（alias declaration）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> myDouble = <span class="keyword">double</span>;</span><br><span class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; (<span class="built_in"><span class="keyword">typeid</span></span>(myDouble) == <span class="built_in"><span class="keyword">typeid</span></span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><ul>
<li>值不会改变，编译过程就能得到计算结果的表达式，字面值就是常量表达式</li>
<li><strong>一个对象或表达式，是否是常量表达式由其数据类型和初值共同决定</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>;   <span class="comment">//是</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files + <span class="number">1</span>;   <span class="comment">//是</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;   <span class="comment">//不是，数据类型不是const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="built_in">get_size</span>();   <span class="comment">//不是，尽管本身是const但具体值需要在&quot;运行时&quot;才能获取</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><ul>
<li><strong>一个复杂系统中几乎不能分辨一个初始值到底是不是常量表达式，C++11允许变量声明为constexpr类型，由编译器验证是否是常量表达式</strong></li>
<li><strong>声明为constexpr的变量一定是一个常量（本质上是赋予了“顶层const”属性），并且必须用常量表达式初始化</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = num + <span class="number">1</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>(); <span class="comment">//当size()是constexpr函数时正确</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Best Practice：如果认定一个变量就是常量表达式，就应该声明为constexpr</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//constexpr函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello2022</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2022</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> hanashi = <span class="built_in">hello2022</span>();<span class="comment">//正确，但是注意函数返回值即使是const int都是错误的，必须constexpr</span></span><br><span class="line">    std::cout &lt;&lt; hanashi;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><ul>
<li>**能初始化constexpr的类型</li>
</ul>
<h2 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h2><ul>
<li><p>解决用表达式给变量赋值时，变量类型难以确定的问题</p>
</li>
<li><p>Compiler会根据表达式结果，自动分析auto对应的类型，所以<strong>auto定义时必须有初值</strong></p>
</li>
<li><p>auto同时声明多个变量时，必须保证声明所有变量的是<strong>同一类型</strong>的变量</p>
</li>
<li><p>将auto当做一个普通的变量类型，会更好理解顶层const被忽略的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">auto</span> pi = <span class="number">3.14</span>, r = <span class="number">2</span>; <span class="comment">//错误，pi与r类型不同</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Compiler推断出的auto类型有时并不和初始值的类型一致，会适当改变结果使其更符合初始化规则</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">//a是一个int类型，因为r只是i的一个别名</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>auto一般会忽略顶层const（变量的const）而保留底层const（通过指针间接指向的变量的const）</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cInt = i, &amp;cRef = cInt;</span><br><span class="line"><span class="keyword">auto</span> b = cInt; <span class="comment">//b是int类型，忽略了顶层const</span></span><br><span class="line"><span class="keyword">auto</span> c = cRef; <span class="comment">//c是int类型，cRef只是一个别名，所以与cInt情况相同</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">//d是int*</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;cInt; <span class="comment">//e是const int*（常量指针，不同于int* const指针常量）</span></span><br></pre></td></tr></table></figure></li>
<li><strong>如果需要推断出auto的类型是顶层const，需要显式声明</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = cInt;</span><br></pre></td></tr></table></figure></li>
<li><strong>可以将引用的类型设置为auto，原来的初始化规则任然适用</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; g = cInt; <span class="comment">//g是一个const int&amp;，与cInt绑定</span></span><br><span class="line"><span class="keyword">auto</span>&amp; h = <span class="number">99</span>; <span class="comment">//错误，不可以为非常量引用绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; k = <span class="number">99</span>; <span class="comment">//正确，可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><ul>
<li><strong>decltype(expr)通过表达式的返回值类型推断出变量类型，并不会实际计算表达式的值</strong></li>
<li>只希望通过表达式推断类型，而不需要用表达式赋值的情况下使用，与auto使用场景不同<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = x; <span class="comment">//sum的类型同func的返回值类型</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(nums.<span class="built_in">size</span>()) i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    std::cout &lt;&lt; nums[i];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h3><ul>
<li>如果decltype使用的表达式返回值是一个引用，则意味着推断结果将是一个引用，需要初始化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">40</span>, *p=&amp;i ,&amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">//正确，加法结果是int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误，*p得到&amp;i，所以结果是一个引用，需要初始化</span></span><br></pre></td></tr></table></figure></li>
<li><strong>如果在decltype的表达式中，变量加了括号，则Compiler会认为括号内是一个表达式，而变量是一种可以作为左值的特殊表达式，因此会被解释为引用类型</strong>（注意这里说的是变量而不是表达式或常量）<blockquote>
<p>WARING：decltype((variable))对变量双层括号的结果永远是引用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误，d是int&amp;必须初始化（error C2530: &#x27;d&#x27;: references must be initialized）</span></span><br><span class="line"><span class="keyword">decltype</span>((i+<span class="number">1</span>)) dd; <span class="comment">//正确，注意表达式和变量的区别</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确，e是未初始化的int</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类内初始值"><a href="#类内初始值" class="headerlink" title="类内初始值"></a>类内初始值</h2><ul>
<li>C++11规定可以为数据成员体同一个“类内初始值（in-class initializer）”</li>
<li>创建对象时，类内初始值将被用于初始化数据成员，没有初始值则会被默认初始化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; obj.a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; obj.b;</span><br><span class="line">    <span class="comment">//output:a:0 b:1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="void-amp-void"><a href="#void-amp-void" class="headerlink" title="void &amp; void*"></a>void &amp; void*</h2><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><ul>
<li>一种特殊用处的类型，既无操作也无值，<strong>不能定义void类型的变量</strong></li>
</ul>
<h3 id="void-1"><a href="#void-1" class="headerlink" title="void*"></a>void*</h3><ul>
<li><strong>可以指向任意任意非常量</strong>的指针类型，<strong>不能直接执行解引用操作</strong></li>
</ul>
<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="字符串的读取"><a href="#字符串的读取" class="headerlink" title="字符串的读取"></a>字符串的读取</h2><h3 id="使用cin以space为划分读取单个单词"><a href="#使用cin以space为划分读取单个单词" class="headerlink" title="使用cin以space为划分读取单个单词"></a>使用cin以space为划分读取单个单词</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word) std::cout &lt;&lt; word &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="使用getline读取整行字符串"><a href="#使用getline读取整行字符串" class="headerlink" title="使用getline读取整行字符串"></a>使用getline读取整行字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string word;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(std::cin, word)) std::cout &lt;&lt; word &lt;&lt; std::endl; <span class="comment">//注意：getline不会保留输入的\n</span></span><br></pre></td></tr></table></figure>



<h2 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h2><ul>
<li>string类以及大多其他C++STL内定义的类，都为了适配各种机器而定义了多种数据类型，使用时通过作用域操作符::区别</li>
<li>可以肯定的是<strong>STL各种size类型都应该是unsigned类型的（注意：C/C++内置的下标类型是有符号的）</strong></li>
<li><strong>由于size返回一个unsigned类型，所以不要与signed类型在表达式中混用！否则会造成如下所示的意外情况</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str&#123; <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vecI&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">-1</span>;</span><br><span class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; (str.<span class="built_in">size</span>() &lt; n) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; (vecI.<span class="built_in">size</span>() &lt; n);<span class="comment">//如果将n改为字面量，则结果正确</span></span><br><span class="line"><span class="comment">//输出结果:true true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>建议使用STL内各种类内部的size_type作为用下标访问时的变量类型，避免越界</strong></li>
</ul>
<h2 id="向量（vector）"><a href="#向量（vector）" class="headerlink" title="向量（vector）"></a>向量（vector）</h2><ul>
<li><strong>vector是类模板</strong>，无论是类模板还是函数模板，使用前都需要实例化（instantiation）</li>
<li><strong>vector是容器，容器内部必须是对象，引用不是对象，因此不能用引用类型实例化容器</strong></li>
<li>早期C++标准中，如果用vector实例化vector需要加一个空格，就像下面的例子一样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="comment">//早期</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="comment">//新标准</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-和-来初始化vector的区别"><a href="#使用-和-来初始化vector的区别" class="headerlink" title="使用 {} 和 () 来初始化vector的区别"></a>使用 {} 和 () 来初始化vector的区别</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vecA&#123; <span class="number">10</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecB</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : vecA) std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : vecB) std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果用初始元素的列表来初始化vector，则只能使用 {} 列表初始化（list initialize），如果使用 {} 但内部的值不能作为列表初始化的类型，则可能会被当做普通的初始化函数调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vec&#123;<span class="number">10</span>&#125;; <span class="comment">//有10个string类默认的初始元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用 () 初始化不指定初始值，则会根据内部变量类型，默认初始化，比如int类型会初始化为0</li>
</ul>
<h3 id="vector对象的高效增长性"><a href="#vector对象的高效增长性" class="headerlink" title="vector对象的高效增长性"></a>vector对象的高效增长性</h3><ul>
<li><strong>C++标准要求vector应该能在运行时高效快速地添加元素，因此defination时是否设计vector的初始大小并不重要，甚至如果设置初始大小反而还会降低性能，除非一种例外：所有元素值相同，此时可以直接用 () 初始化（个人认为高效的原因是内部调用了类似memset的底层函数）</strong></li>
<li><strong>vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间，因此对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</strong></li>
</ul>
<h2 id="初识迭代器"><a href="#初识迭代器" class="headerlink" title="初识迭代器"></a>初识迭代器</h2><ul>
<li><strong>所有标准库容器都可以使用迭代器（iterator），但是只有少数几种容器才同时支持下标运算符[]</strong></li>
<li>使用类似于指针，有效迭代器：指向容器内元素 或 指向容器尾元素的下一个位置</li>
</ul>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><ul>
<li><strong>使用上却不同于指针，获取迭代器不能通过取地址符&amp;，但是在获取所指向元素时，都是使用解引用符</strong>*</li>
<li>*<em>注意：成员访问符 . 的优先级大于 解引用 * ，例：(<em>it).empty() //正确</em></em></li>
<li>拥有迭代器的类，同时会有返回迭代器的成员，比如至少有 指向容器第一个元素的迭代器being 和 指向容器尾元素下一个元素的end（通常也被称为 尾后迭代器[off-the-end iterator] 或 尾迭代器[end iterator]）</li>
<li><strong>如果容器为空，则begin和end返回的是同一个迭代器：尾迭代器</strong></li>
<li><strong>两个有效迭代器相减会返回相距位置大小，类型是 dirrerence_type 是一个有符号类型（两个指针相减会返回 ptrdiff_t 类型）</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string s&#123;<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) <span class="comment">//注意：不要使用auto&amp;</span></span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="为什么对迭代器使用-而不是-lt-（泛型编程）"><a href="#为什么对迭代器使用-而不是-lt-（泛型编程）" class="headerlink" title="为什么对迭代器使用 != 而不是 &lt;（泛型编程）"></a>为什么对迭代器使用 != 而不是 &lt;（泛型编程）</h3><ul>
<li><p><strong>不同于C和Java程序习惯用下标访问容器，C++程序员更倾向于用迭代器访问容器，因为STL所有容器都支持迭代器，而不一定支持下标访问</strong></p>
</li>
<li><p><strong>STL所有容器的迭代器都定义了 == 和 != 但是大多没有定义 &lt; 运算符</strong></p>
</li>
</ul>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><ul>
<li><p><strong>就像不知道类的size_type成员的实际类型一样，一般也不需要知道迭代器的类型</strong></p>
</li>
<li><p><strong>实际上，拥有迭代器的STL类使用 iterator 和 const_iterator 来表示迭代器类型</strong></p>
</li>
<li><p><strong>iterator</strong>：当容器本身不是const时使用</p>
</li>
<li><p><strong>const_iterator</strong>：无论容器是否是const都可以使用</p>
</li>
<li><p><strong>当不得不需要 const_iterator 时，C++11提供了 cbein 和 cend ，无论对象是否是const二者都会返回const_iterator</strong></p>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="标准库函数std-begin-和std-end"><a href="#标准库函数std-begin-和std-end" class="headerlink" title="标准库函数std::begin()和std::end()"></a>标准库函数std::begin()和std::end()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* beg = std::<span class="built_in">begin</span>(nums);</span><br><span class="line"><span class="keyword">int</span>* last = std::<span class="built_in">end</span>(nums);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以用数组初始化vector对象</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec&#123;std::<span class="built_in">begin</span>(nums),std::<span class="built_in">end</span>(nums)&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">        std::cout &lt;&lt; (*it);</span><br></pre></td></tr></table></figure>

<h3 id="使用-范围for（range-based-for）-处理多维数组"><a href="#使用-范围for（range-based-for）-处理多维数组" class="headerlink" title="使用 范围for（range-based-for） 处理多维数组"></a>使用 范围for（range-based-for） 处理多维数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">1</span>,<span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>,<span class="number">4</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : matrix) <span class="comment">//非最内层必须使用auto&amp;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row) std::cout &lt;&lt; col &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用range-based-for时，非最内层的循坏外，都应该确保控制变量是 引用 类型，否则可能将数组指针解释为普通指针（数组首位置）</strong></li>
<li><strong>多维数组是数组的数组，仔细分析上述遍历过程，本质上是外层获取数组指针，内层在数组指针指向的空间中遍历</strong></li>
</ul>
<h3 id="使用类型别名简化多维数组的指针"><a href="#使用类型别名简化多维数组的指针" class="headerlink" title="使用类型别名简化多维数组的指针"></a>使用类型别名简化多维数组的指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> intArray2 = <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">1</span>,<span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>,<span class="number">4</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (intArray2* p = matrix; p != matrix + <span class="number">2</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>* q = *p; q != (*p) + <span class="number">2</span>; q++) std::cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="整型提升（intergral-promotion）"><a href="#整型提升（intergral-promotion）" class="headerlink" title="整型提升（intergral promotion）"></a>整型提升（intergral promotion）</h3><ul>
<li><strong>负责将小整数类型转换为较大的整数类型</strong>（注意是整数）</li>
<li><strong>为了效率的提升：常发生在char || unsigned char || short || unsigned short，如果int足够表达将提升为int，否则提升为unsigned int，因为int类型是现代计算机所能处理的类型中效率最高的类型（自然类型）</strong></li>
<li><strong>为了精度的提升：在运算中，以运算中表达范围更大的对象为目标，其他对象向该目标类型提升</strong></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++Primer》函数 [2]</title>
    <url>/2021/12/12/C++/C++Primer-Review%5B2%5D/</url>
    <content><![CDATA[<ul>
<li>参考书籍《C++Primer 中文版 5th》</li>
</ul>
<span id="more"></span>

<h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><ul>
<li>对引用的操作实际上是操作“被引用的对象”，因此<strong>使用引用避免拷贝</strong></li>
<li><strong>拷贝大的class对象或者容器对象非常低效，有些类（比如IO类）根本就不支持拷贝操作</strong></li>
<li>当不支持拷贝操作时，函数只能通过引用形参访问该类型对象</li>
<li><strong>如果函数无需改变引用的值，最好声明为const &amp;</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> std::string &amp;str1 , <span class="keyword">const</span> std::string &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Const形参和实参"><a href="#Const形参和实参" class="headerlink" title="Const形参和实参"></a>Const形参和实参</h2><ul>
<li><strong>实参初始化形参过程中，会忽略实参的顶层const，举个例子可以用const int给int类型赋值或初始化</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num)</span></span>&#123;<span class="comment">/*函数内部可以读取num但是不能写*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;&#125; <span class="comment">//Error：重复定义了func(int)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：在重载函数时，由于顶层const会被忽略，所以上面两个函数实际上是完全一样的参数列表，根据上下文情况应该保留第一个</strong></li>
</ul>
<h2 id="main处理命令行选项"><a href="#main处理命令行选项" class="headerlink" title="main处理命令行选项"></a>main处理命令行选项</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个形参argc表示了第二个形参argv中字符串的数量</li>
<li>第二个形参argv是指针数组，当实参传递给main()后，argv的第一个元素argv[0]将指向程序名或一个空字符串，其他传入的用户参数依次填入[1,2,3…]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">program -d -o ofile data0</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;program&quot;</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-d&quot;</span></span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;-o&quot;</span></span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;ofile&quot;</span></span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">&quot;data0&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++构造函数和析构函数</title>
    <url>/2022/01/25/C++/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li>探讨C++的构造函数（Constructor）与析构函数（Destructor）主要性质</li>
</ul>
<span id="more"></span>

<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><ul>
<li>无论是构造函数还是析构函数，都是不写返回值类型的</li>
</ul>
<h2 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h2><h3 id="内部执行顺序"><a href="#内部执行顺序" class="headerlink" title="内部执行顺序"></a>内部执行顺序</h3><ol>
<li><strong>动态分配内存</strong>：对void*调用C语言的malloc动态分配内存</li>
<li><strong>类型转换</strong>：使用static_cast&lt;对象类型&gt;将void*转换为相应的对象类型</li>
<li><strong>执行构造函数</strong>：转换后调用对象的构造函数</li>
</ol>
<h3 id="初始化列表（Initialization-List）"><a href="#初始化列表（Initialization-List）" class="headerlink" title="初始化列表（Initialization List）"></a>初始化列表（Initialization List）</h3><ul>
<li>只有构造函数才有初始化列表（Initialization List）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>():real&#123;<span class="number">0</span>&#125;,imaginary&#123;<span class="number">0</span>&#125;&#123;&#125;;<span class="comment">//初始化列表</span></span><br><span class="line">    <span class="comment">//Complex()&#123;real=0;imaginary=0&#125;;//赋值</span></span><br><span class="line">pirvate:</span><br><span class="line">    <span class="keyword">double</span> real,imaginary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>任何对象的生成有两个步骤：①初始化 ②赋值</strong></li>
<li>对于上面的代码，两种构造函数在结果上都是一样的，<strong>但是“赋值”方法相当于“放弃了初始化”这步骤，因此将造成性能损失，使用初始化列表的做法更加Pro</strong></li>
</ul>
<h2 id="析构函数（Destructor）"><a href="#析构函数（Destructor）" class="headerlink" title="析构函数（Destructor）"></a>析构函数（Destructor）</h2><h3 id="内部执行顺序-1"><a href="#内部执行顺序-1" class="headerlink" title="内部执行顺序"></a>内部执行顺序</h3><ol>
<li><strong>执行析构函数</strong>：调用this的析构函数</li>
<li><strong>释放内存</strong>：调用C语言的free</li>
</ol>
<h3 id="如果要继承就要使用虚函数"><a href="#如果要继承就要使用虚函数" class="headerlink" title="如果要继承就要使用虚函数"></a>如果要继承就要使用虚函数</h3><ul>
<li>虚函数可以保证使用父类指针new的子类能够正确调用自身的析构函数，防止内存泄露</li>
</ul>
<h1 id="在C-两类对象中的表现"><a href="#在C-两类对象中的表现" class="headerlink" title="在C++两类对象中的表现"></a>在C++两类对象中的表现</h1><h2 id="没有指针的对象"><a href="#没有指针的对象" class="headerlink" title="没有指针的对象"></a>没有指针的对象</h2><ul>
<li>可以使用编译器提供的默认构造函数，即不需要自己写</li>
</ul>
<h2 id="有指针的对象"><a href="#有指针的对象" class="headerlink" title="有指针的对象"></a>有指针的对象</h2><ul>
<li>某些情况下也可以不写，但是<strong>原则上一定要写，防止意外导致的内存泄漏</strong>，至于究竟会不会发生内存泄露与C++对象在内存中的形式有关</li>
</ul>
<h2 id="delete与delete"><a href="#delete与delete" class="headerlink" title="delete与delete[]"></a>delete与delete[]</h2><ul>
<li><strong>对于“有指针的对象”组成的数组，原则上一定要使用delete[]释放内存，如果使用delete则只会执行第一个对象的析构函数</strong></li>
<li><strong>delete[] 可以从C++对象的内存模型中获取数组大小，从而对数组中每个对象执行delete</strong></li>
<li><strong>从上面两点可以大致感觉到：有些情况下如果不使用delete[]也不会造成内存泄漏。不过具体原因与C++在不同环境下的内存模型有关，之后会抽时间单独整理相关笔记</strong></li>
</ul>
<h1 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h1><h2 id="继承-组合（Inheritance-Composition）"><a href="#继承-组合（Inheritance-Composition）" class="headerlink" title="继承+组合（Inheritance+Composition）"></a>继承+组合（Inheritance+Composition）</h2><ul>
<li><strong>这个实验结果对单独地 组合（+Composition） 或 继承（Inheritance）情况也是一样的</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E_Bike is a Bike（Inheritance），E_Bike has a Battery（Composition）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Battery</span>() &#123; cout &lt;&lt; <span class="string">&quot;Battery is allocating!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">Battery</span>() &#123; cout &lt;&lt; <span class="string">&quot;Battery is deleting!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bike</span>() &#123; cout &lt;&lt; <span class="string">&quot;Bike is allocating!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Bike</span>() &#123; cout &lt;&lt; <span class="string">&quot;Bike is deleting!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E_Bike</span></span></span><br><span class="line"><span class="class">	:</span><span class="keyword">public</span> Bike</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">E_Bike</span>() &#123; cout &lt;&lt; <span class="string">&quot;E_Bike is allocating!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">E_Bike</span>() &#123; cout &lt;&lt; <span class="string">&quot;E_Bike is deleting!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Battery battery;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Output</span></span><br><span class="line">[ Constructing ]</span><br><span class="line">Bike is allocating!</span><br><span class="line">Battery is allocating!</span><br><span class="line">E_Bike is allocating!</span><br><span class="line"></span><br><span class="line">[ Destructing ]</span><br><span class="line">E_Bike is deleting!</span><br><span class="line">Battery is deleting!</span><br><span class="line">Bike is deleting!</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h3><ul>
<li><strong>继承&gt;组合&gt;自己</strong>：对于电动自行车（E_Bike），首先需要具备一个普通自行车（Bike）所有的特性，并且拥有电池（Battery）才行</li>
</ul>
<h3 id="析构函数的执行顺序"><a href="#析构函数的执行顺序" class="headerlink" title="析构函数的执行顺序"></a>析构函数的执行顺序</h3><ul>
<li><strong>自己&gt;组合&gt;继承</strong>：构造的顺序刚好相反，可以不想太多，但其实也很自然，销毁E_Bike首先要去除电动车本身的外壳之类的，再将可以再利用的Battery回收，最后当做一个普通的Bike处理</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>『Eigen』 GettingStart（入门篇）</title>
    <url>/2021/11/07/C++/Eigen-GettingStart/</url>
    <content><![CDATA[<ul>
<li>本篇文章主要介绍了Eigen库最基本的知识和使用方法</li>
<li>参考资料：<a href="https://eigen.tuxfamily.org/dox/GettingStarted.html">Eigen官方文档</a></li>
</ul>
<span id="more"></span>

<h2 id="一个简单的例子（-A-simple-first-program）"><a href="#一个简单的例子（-A-simple-first-program）" class="headerlink" title="一个简单的例子（ A simple first program）"></a>一个简单的例子（ A simple first program）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Eigen::MatrixXd;</span><br><span class="line">    <span class="function">MatrixXd <span class="title">mat</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;<span class="comment">//设置尺寸2X2，注意Eigen不会对Matrix或Vector初始化</span></span><br><span class="line">    mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;<span class="comment">//这里使用了所谓的“comma initializer”</span></span><br><span class="line">    <span class="built_in">mat</span>(<span class="number">1</span>, <span class="number">1</span>) = <span class="built_in">mat</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//★：使用“圆括弧”而不是“方括弧”</span></span><br><span class="line">    cout &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(mat).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//测试矩阵数据是double类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details><summary><b>▷ 点这里看看结果是否和你想的一样</b></summary>
    1 2<br/>
    3 1<br/>
    class Eigen::Matrix<double,-1,-1,0,-1,-1>
</details>

<h2 id="对第一个程序的解释（Explanation-of-the-first-program）"><a href="#对第一个程序的解释（Explanation-of-the-first-program）" class="headerlink" title="对第一个程序的解释（Explanation of the first program）"></a>对第一个程序的解释（Explanation of the first program）</h2><ul>
<li>Eigen定义了非常多的类型，但<strong>通常使用 MatrixXd 就足够了</strong>，X代表矩阵尺寸是任意的，d代表数据是double类型的</li>
<li>Eigen/Dense在namespace Eigen中定义了MatrixXd的所有成员函数以及相关的数据类型</li>
<li><strong>Eigen不会对Matrix或Vector初始化，如果需要零矩阵或零向量需要使用 setZero</strong></li>
</ul>
<p><strong>▽  以下为来自官方文档的相关信息</strong></p>
<ul>
<li> <a href="https://eigen.tuxfamily.org/dox/group__QuickRefPage.html#QuickRef_Types">Eigen提供的数据类型</a></li>
<li><a href="https://eigen.tuxfamily.org/dox/group__QuickRefPage.html#QuickRef_Headers">Eigen的头文件表</a></li>
<li><a href="https://eigen.tuxfamily.org/dox/group__TutorialAdvancedInitialization.html">Eigen Comma Initializer</a></li>
</ul>
<h2 id="矩阵与向量（Matrices-and-Vectors）"><a href="#矩阵与向量（Matrices-and-Vectors）" class="headerlink" title="矩阵与向量（Matrices and Vectors）"></a>矩阵与向量（Matrices and Vectors）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Matrices (Size set at run time) 使用MatrixXd时，矩阵尺寸在运行时确定</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line">    MatrixXd matX = MatrixXd::<span class="built_in">Random</span>(<span class="number">3</span>, <span class="number">3</span>);<span class="comment">//默认随机范围[-1,1]</span></span><br><span class="line">    matX = (matX + MatrixXd::<span class="built_in">Constant</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1.2</span>)) * <span class="number">50</span>;<span class="comment">//线性映射将范围映射到[10,110]</span></span><br><span class="line">    <span class="comment">//MatrixXd::Constant(row, col, value)会创建一个所有元素是value的矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MatX =&quot;</span> &lt;&lt; endl &lt;&lt; matX &lt;&lt; endl;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Matrices (Size set at compile time) 使用固定尺寸的矩阵，会在编译时就确定大小</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line">    Matrix3d matFix = Matrix3d::<span class="built_in">Random</span>();</span><br><span class="line">    matFix = (matFix + Matrix3d::<span class="built_in">Constant</span>(<span class="number">1.2</span>)) * <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MatFix =&quot;</span> &lt;&lt; endl &lt;&lt; matFix &lt;&lt; endl;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Vectors 可以使用VectorXd创建一个任意维度的向量</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line">    VectorXd vec&#123; <span class="number">3</span> &#125;;<span class="comment">//设置维度为3，再次提醒Eigen不会对Matrix或Vector初始化</span></span><br><span class="line">    vec &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; vec &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MatX * vec = &quot;</span> &lt;&lt; endl &lt;&lt; matX * vec &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Eigen的Matrix默认使用列主序，Vector默认使用右手系</strong></li>
</ul>
<details><summary><b>▷ 点这里看看结果是否和你想的一样</b></summary>
    10.1251 90.8741 45.0291<br/>
    66.3585 68.5009 99.5962<br/>
    29.3304 57.9873  92.284<br/>
    1<br/>
    2<br/>
    3<br/>
    MatX * vec =<br/>
    326.961<br/>
    502.149<br/>
    422.157<br/>
    MatFix =<br/>
    84.6605 81.0501 11.4985<br/>
    27.4108 61.3535 19.1403<br/>
    95.8943 40.3995 46.4452<br/>
</details>

<h2 id="使用固定尺寸的矩阵和向量的两个好处（Two-advantages-of-Fixed-size-matrices-and-vectors）"><a href="#使用固定尺寸的矩阵和向量的两个好处（Two-advantages-of-Fixed-size-matrices-and-vectors）" class="headerlink" title="使用固定尺寸的矩阵和向量的两个好处（Two advantages of Fixed-size matrices and vectors）"></a>使用固定尺寸的矩阵和向量的两个好处（Two advantages of Fixed-size matrices and vectors）</h2><ul>
<li><strong>编译器可以更快映射</strong>，因为已知尺寸<blockquote>
<blockquote>
<p> The compiler emits better (faster) code because it knows the size of the matrices and vectors. </p>
</blockquote>
</blockquote>
</li>
<li>在编译时，具体的尺寸可以<strong>更容易检测出一些小错误</strong><blockquote>
<blockquote>
<p> Specifying the size in the type also allows for more rigorous checking at compile-time.</p>
</blockquote>
</blockquote>
</li>
<li><strong>一个好的习惯：在使用小于4*4尺寸的矩阵或向量时，使用固定大小的矩阵和向量</strong><blockquote>
<blockquote>
<p> A rule of thumb is to use fixed-size matrices for size 4-by-4 and smaller.</p>
</blockquote>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++17 STL Cookbook》笔记</title>
    <url>/2021/10/30/C++/%E3%80%8AC++17%20STL%20Cookbook%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>“本书仅课余时间阅读并且当做英语翻译练习，因此更新速度较慢，非常感谢参考译文作者们”</strong><br><strong>参考书籍：《C++17 STL Cookbook》</strong><br><strong>译文参考：(<a href="https://github.com/xiaoweiChen/CPP-17-STL-cookbook">https://github.com/xiaoweiChen/CPP-17-STL-cookbook</a>)</strong></p>
<span id="more"></span>

<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><ul>
<li><p><strong>C++的部分模板类是</strong><a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/4634934">图灵完备</a><strong>的!</strong></p>
<blockquote>
<p>The part of C++ for expressing template types is even Turing-complete!</p>
</blockquote>
</li>
<li><p><strong>许多程序员仅仅把C++当做一门编程语言学习，并不重视STL的使用，这让C++看起来像是具有class的C语言。这样不仅看起来不像是21世纪的现代程序，并且失去了C++一半的力量。</strong></p>
<blockquote>
<p>However, many C++ programmers eagerly learn C++ as a language but put its standard<br> library, the STL, in the second place. Using the C++ language without the help that the<br> standard library provides often leads to programs that look like C with classes, but not<br> what modern programs in the 21st century should look like. This is very sad because using<br> C++ like that means dropping half its strength.</p>
</blockquote>
</li>
<li><p><strong>C++之父Bjarne Stroustrup博士在他的《C++程序设计语言》(C++11版本)中写到</strong><br> “STL和语言特性都是为了支撑以软件质量为目标的编程技术，他们应该互相配合发挥作用——就如同搭建房子的砖块——而不是单独拿出来，相对孤立地解决一个具体问题。”</p>
<blockquote>
<p>In the C++11 edition of his book, The C++ Programming Language, Bjarne Stroustrup writes,<br> “Please remember that those libraries and language features exist to support programming<br> techniques for developing quality software. They are meant to be used in combination–as<br> bricks in a building set–rather than to be used individually in relative isolation to solve a<br> specific problem.”</p>
</blockquote>
</li>
</ul>
<h1 id="Chapter1-C-17新特新（The-New-C-17-Features）"><a href="#Chapter1-C-17新特新（The-New-C-17-Features）" class="headerlink" title="Chapter1.C++17新特新（The New C++17 Features）"></a>Chapter1.C++17新特新（The New C++17 Features）</h1><h2 id="Abstract-摘要"><a href="#Abstract-摘要" class="headerlink" title="Abstract 摘要"></a>Abstract 摘要</h2><ol>
<li><strong>使用 结构化绑定（structured bindings）去解包绑定的返回值</strong><blockquote>
<p>Using structured bindings to unpack bundled return values</p>
</blockquote>
</li>
<li><strong>限制 变量作用域（variable scopes）在 if 和 switch 区域内</strong><blockquote>
<p>Limiting variable scopes to if and switch statements</p>
</blockquote>
</li>
<li><strong>从新的 括号初始化规则（bracket initializer rules）中获益</strong><blockquote>
<p>Profiting from the new bracket initializer rules</p>
</blockquote>
</li>
<li><strong>让构造函数（constructor）自动推导模板的类型</strong><blockquote>
<p>Letting the constructor automatically deduce the resulting template class type</p>
</blockquote>
</li>
<li><strong>使用 constexpr-if 简化编译时决策</strong><blockquote>
<p>Simplifying compile-time decisions with constexpr-if</p>
</blockquote>
</li>
<li><strong>使用内联变量（inline variables）启动只有头文件的库（header-only library）</strong><blockquote>
<p>Enabling header-only libraries with inline variables</p>
</blockquote>
</li>
<li><strong>使用折叠表达式（fold expressions）方便地实现辅助函数</strong><blockquote>
<p>Implementing handy helper functions with fold expressions</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++ STL</tag>
      </tags>
  </entry>
  <entry>
    <title>辨别常量指针与指针常量</title>
    <url>/2021/12/18/C++/%E8%BE%A8%E5%88%AB%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<ul>
<li>自己总结的一种“区别指针常量与常量指针”的方法，从底层原理出发一次解决</li>
</ul>
<span id="more"></span>

<h2 id="从实例出发"><a href="#从实例出发" class="headerlink" title="从实例出发"></a>从实例出发</h2><ul>
<li>下面的例子例举了一个类型的指针所能出现的所有情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, ii = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> typePointConst = &amp;i;</span><br><span class="line">typePointConst = &amp;ii;   <span class="comment">//Error:expression must be a modifiable value</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(typePointConst).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//output:int*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* typeConstPoint = &amp;i;</span><br><span class="line">typeConstPoint = &amp;ii;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(typeConstPoint).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//output:int const*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* constTypePoint = &amp;i;</span><br><span class="line">constTypePoint = &amp;ii;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(constTypePoint).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//output:int const*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>* <span class="keyword">int</span> constPointType = &amp;i;   <span class="comment">//Error:不存在该类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由《C专家编程》（也可能是另一本，两年前看的有点记不清了）中介绍，C语言使用“大口法”来解释语句，换句话说一行代码（以分号分割）的解释是从左到右，并且在有意义的前提下尽可能让一个意群更大（借用英语中的意群概念），因此 const 常量声明只能用作离自己最近的基本数据类型，否则无意义</li>
<li>对于第一个例子：int* const 意群的变化：无符号整型（可以扩大） -&gt; 无符号整型指针（还可以扩大） -&gt; 无符号整型指针+常量（无法扩大，且声明结束），因此在第三步需要将const作用于最近的基本数据类型 int* 所以最终是一个“常量的整型指针”，也就是指针常量</li>
<li>对于第二个例子：int const*意群的变化：无符号整型（可以扩大）-&gt;常量无符号整型（无法扩大）-&gt;常量无符号整型的指针（意群可以扩大，但声明结束），因此const仅仅修饰了int而最后的指针类型修饰了const int，所以最后是“指向整型常量的指针”，也就是常量指针</li>
<li>对于第三个例子const int*，与第二个例子类似，只要知道const只修饰最近的类型</li>
<li>按照第三个例子的解释，第四个例子const* int为什么无效也很容易解释：一个没有明确指出类型的指针被const修饰怎么可能有意义？</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101笔记——变换与光栅化</title>
    <url>/2021/12/24/ComputerGraphics/Games101-%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View / Camera Transformation"></a>View / Camera Transformation</h1><ul>
<li>三维空间的物体到二维平面的过程中，究竟发生了什么？</li>
</ul>
<span id="more"></span>

<h2 id="什么是观测变换？（What-is-view-transformation）"><a href="#什么是观测变换？（What-is-view-transformation）" class="headerlink" title="什么是观测变换？（What is view transformation）"></a>什么是观测变换？（What is view transformation）</h2><h3 id="试想如何拍一张照片（MVP）："><a href="#试想如何拍一张照片（MVP）：" class="headerlink" title="试想如何拍一张照片（MVP）："></a>试想如何拍一张照片（MVP）：</h3><ul>
<li>找到合适的<strong>拍摄点</strong>，将拍摄对象安排在合适的位置<strong>（Model:模型变化）</strong></li>
</ul>
<blockquote>
<p>Find a good <strong>place</strong> and arrange people (model transformation)</p>
</blockquote>
<ul>
<li>找到合适的<strong>拍摄角度</strong>，将相机拿好<strong>（View:视图变换）</strong></li>
</ul>
<blockquote>
<p>Find a good <strong>angle</strong> to put the camera (view transformation)</p>
</blockquote>
<ul>
<li>茄子！<strong>（Projection:投影变化）</strong></li>
</ul>
<blockquote>
<p>Cheese! (projection transformation)</p>
</blockquote>
<h3 id="怎样描述观测变换："><a href="#怎样描述观测变换：" class="headerlink" title="怎样描述观测变换："></a>怎样描述观测变换：</h3><ol>
<li>首先需要定义一个具有以下属性的相机（Camera）</li>
</ol>
<ul>
<li>相机位置（Position）：e</li>
<li>镜头方向（Look at / Gaze direction）：g</li>
<li>正上方向（Up direction）：t</li>
</ul>
<ol start="2">
<li>定义主观测点（Key observation）</li>
</ol>
<ul>
<li>拿着相机找位置拍摄  和  让物体移动到相机前，最终效果是一样的</li>
<li>为了便于计算，通常相机是定点的，而让物体移动</li>
<li><strong>Camera标准位置：①Camera在原点位置 ②Camera看向 -Z 方向 ③ +Y方向为Camera正上方向</strong></li>
</ul>
<h3 id="如何实现观测变换"><a href="#如何实现观测变换" class="headerlink" title="如何实现观测变换"></a>如何实现观测变换</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224183520562.png" alt="image-20211224183520562"></p>
<ul>
<li>首先对所有物体做平移变换移动到原点位置</li>
<li>然后将朝向（g x t,  t, g）转到Camera标准朝向（x,y,z）（由于将某个特定向量旋转到x,y,z比较难计算，而将x,y,z转到特定向量却很好表示，因此利用旋转矩阵特性，这里使用逆变换表示）</li>
</ul>
<h2 id="投影变换（Projection-Transformation）"><a href="#投影变换（Projection-Transformation）" class="headerlink" title="投影变换（Projection Transformation）"></a>投影变换（Projection Transformation）</h2><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224190113109.png" alt="image-20211224190113109"></p>
<h3 id="正交投影（Orthographic-Projection）"><a href="#正交投影（Orthographic-Projection）" class="headerlink" title="正交投影（Orthographic Projection）"></a>正交投影（Orthographic Projection）</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224190210429.png" alt="image-20211224190210429"></p>
<h3 id="如何实现正交投影"><a href="#如何实现正交投影" class="headerlink" title="如何实现正交投影"></a>如何实现正交投影</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224190236747.png" alt="image-20211224190236747"></p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224190746448.png" alt="image-20211224190746448"></p>
<ul>
<li>首先需要定义一个立方体（图左一类似）</li>
<li>然后将定义的正方体通过一系列变换，转变为<strong>标准立方体（canonical cube）</strong></li>
<li><strong>标准立方体</strong>：X [-1,1] Y [-1,1] Z [-1,1]</li>
<li>这个过程中物体会形变，不过在显示到屏幕前还需要<strong>视口变换</strong></li>
</ul>
<h3 id="透视投影（Perspective-Projection）"><a href="#透视投影（Perspective-Projection）" class="headerlink" title="透视投影（Perspective Projection）"></a>透视投影（Perspective Projection）</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224190805009.png" alt="image-20211224190805009"></p>
<h3 id="如何实现透视投影"><a href="#如何实现透视投影" class="headerlink" title="如何实现透视投影"></a>如何实现透视投影</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224191002963.png" alt="image-20211224191002963"></p>
<ul>
<li><strong>回想一下在齐次坐标中：（x,y,z,1）与 (wx,wy,wz,w) 表示同一个点</strong></li>
<li><strong>实现透视投影，可以分解为两步：①挤压Frustum使其变为Cuboid ②正交投影</strong></li>
<li><strong>在①中，我们规定的Frustum的近平面（n）和远平面（f）的 z 坐标不变，这对我们最后求解透视矩阵非常关键</strong></li>
</ul>
<h3 id="透视矩阵的推导"><a href="#透视矩阵的推导" class="headerlink" title="透视矩阵的推导"></a>透视矩阵的推导</h3><ul>
<li>①寻找压缩过程中的几何关系</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224191751154.png" alt="image-20211224191751154"></p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224191807478.png" alt="image-20211224191807478"></p>
<ul>
<li>②根据几何关系推断矩阵的部分未知量</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224191820101.png" alt="image-20211224191820101"></p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224192117956.png" alt="image-20211224192117956"></p>
<ul>
<li>③现在还有两个未知量，我们需要利用前面远平面和近平面的特性来求解</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224192155082.png" alt="image-20211224192155082"></p>
<ul>
<li>④得到从投影矩阵到正交矩阵的变换矩阵M(persp-&gt;ortho)</li>
<li><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224192316121.png" alt="image-20211224192316121"></li>
</ul>
<h3 id="补充问题的求解：对于Frustum中间的点在挤压过程中Z值应该如何变化？"><a href="#补充问题的求解：对于Frustum中间的点在挤压过程中Z值应该如何变化？" class="headerlink" title="补充问题的求解：对于Frustum中间的点在挤压过程中Z值应该如何变化？"></a>补充问题的求解：对于Frustum中间的点在挤压过程中Z值应该如何变化？</h3><ul>
<li>由于Hexo没有成功解析数学公式，所以采用图片方式展示推导过程</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211227174129852.png" alt="image-20211227174129852"></p>
<blockquote>
<p>在推导之后，我苦苦思考怎么找一个现实中的例子来证明这个结果，想了半天没有想出来，最后在知乎上找到某大佬的铁道举例，感觉非常直观</p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224195728911.png" alt="image-20211224195728911"></p>
</blockquote>
<h1 id="视角（FOV-Field-Of-View）"><a href="#视角（FOV-Field-Of-View）" class="headerlink" title="视角（FOV,  Field-Of-View）"></a>视角（FOV,  Field-Of-View）</h1><h2 id="如何定义视角？"><a href="#如何定义视角？" class="headerlink" title="如何定义视角？"></a>如何定义视角？</h2><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224201618537.png" alt="image-20211224201618537"></p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224201634742.png" alt="image-20211224201634742"></p>
<ul>
<li><strong>通过上面的转换公式可以知道：得到一个FOV只需要定义 ①垂直可视角度 ②宽高比</strong></li>
</ul>
<h1 id="在MVP之后会发生什么？"><a href="#在MVP之后会发生什么？" class="headerlink" title="在MVP之后会发生什么？"></a>在MVP之后会发生什么？</h1><ul>
<li><strong>如何将MVP之后得到的Canonical Cube（标准立方体）绘制到屏幕上？</strong></li>
</ul>
<h2 id="视口变换（Viewport-Transformation）"><a href="#视口变换（Viewport-Transformation）" class="headerlink" title="视口变换（Viewport Transformation）"></a>视口变换（Viewport Transformation）</h2><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224202000451.png" alt="image-20211224202000451"></p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224202637593.png" alt="image-20211224202637593"></p>
<ul>
<li><p><strong>Z轴不变，X轴和Y轴分别移动到坐标系左下角[0,width]和[0,height]</strong></p>
</li>
<li><p><strong>注意视口变换矩阵的变换顺序：先缩放再平移</strong></p>
</li>
</ul>
<h2 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h2><h3 id="阴极射线管（CRT，Cathode-Ray-Tube）"><a href="#阴极射线管（CRT，Cathode-Ray-Tube）" class="headerlink" title="阴极射线管（CRT，Cathode Ray Tube）"></a>阴极射线管（CRT，Cathode Ray Tube）</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224203521717.png" alt="image-20211224203521717"></p>
<h3 id="液晶显示器（LCD，Liquid-Crystal-Display）"><a href="#液晶显示器（LCD，Liquid-Crystal-Display）" class="headerlink" title="液晶显示器（LCD，Liquid Crystal Display）"></a>液晶显示器（LCD，Liquid Crystal Display）</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224203626884.png" alt="image-20211224203626884"></p>
<h3 id="帧缓存（Frame-Buffer）"><a href="#帧缓存（Frame-Buffer）" class="headerlink" title="帧缓存（Frame Buffer）"></a>帧缓存（Frame Buffer）</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224203714402.png" alt="image-20211224203714402"></p>
<ul>
<li><p><strong>显示在屏幕上的图像实际上就是内存中的一块特殊区域</strong></p>
</li>
<li><p>了解光栅化的方式对学习白平衡和伽马矫正等色彩相关的知识有一定帮助</p>
</li>
</ul>
<h3 id="轴向包围盒（AABB，Axis-Aligned-Bounding-Box）"><a href="#轴向包围盒（AABB，Axis-Aligned-Bounding-Box）" class="headerlink" title="轴向包围盒（AABB，Axis-Aligned-Bounding-Box）"></a>轴向包围盒（AABB，Axis-Aligned-Bounding-Box）</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224204724699.png" alt="image-20211224204724699"></p>
<ul>
<li><strong>光栅化过程只对Bounding Box（蓝色包围区域）生效，因此可以节约很多算力</strong></li>
<li><strong>但是对于“细长三角形”，其AABB会很大，但实际上并没有多少有效像素，这个角度也可以作为“为什么正三角形是网格优化的最佳指标”的原因之一</strong></li>
</ul>
<h3 id="实际应用中的LCD屏幕像素排列"><a href="#实际应用中的LCD屏幕像素排列" class="headerlink" title="实际应用中的LCD屏幕像素排列"></a>实际应用中的LCD屏幕像素排列</h3><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211224205203010.png" alt="image-20211224205203010"></p>
<ul>
<li><strong>以Galaxy S5的像素拜耳排列（bayer pattern）为例，由于人眼对绿色更加敏感，所以绿色的频率更高，红色和蓝色频率基本一样（从图像处理角度，这就是一种量化方式）</strong></li>
</ul>
<h1 id="深度缓存（Z-Buffer）"><a href="#深度缓存（Z-Buffer）" class="headerlink" title="深度缓存（Z-Buffer）"></a>深度缓存（Z-Buffer）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211227180328524.png" alt="image-20211227180328524"></p>
<ul>
<li><strong>深度缓存（Z-Buffer）是生成帧缓存（Frame Buffer）时，同步生成并存储的另一片内存区域</strong></li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211227180533220.png" alt="image-20211227180533220"></p>
<ul>
<li><strong>以像素点为单位，保存屏幕中每一个像素点的最近的深度值</strong>（注意：最近不一定最小）</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211227180554210.png" alt="image-20211227180554210"></p>
<h2 id="计算深度缓存时的一些问题"><a href="#计算深度缓存时的一些问题" class="headerlink" title="计算深度缓存时的一些问题"></a>计算深度缓存时的一些问题</h2><p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20211227180733684.png" alt="image-20211227180733684"></p>
<ul>
<li><strong>深度缓存只是在对每个像素点求最小深度，而并没有排序，所以在O(n)时间内完全可以实现</strong></li>
<li><strong>当两个片元在某像素点深度值相同时，处理方法比较复杂，需要依据需求参考更加权威的资料</strong></li>
<li><strong>深度缓存无法处理透明物体，透明物体需要特殊处理</strong></li>
</ul>
]]></content>
      <categories>
        <category>CG</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>每日学习打卡</title>
    <url>/2022/01/19/Daily/DailyAttendance/</url>
    <content><![CDATA[<ul>
<li><strong>坚持每日学习打卡，内容主要以外语学习为主</strong></li>
</ul>
<span id="more"></span>

<h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="January"><a href="#January" class="headerlink" title="January"></a>January</h2><h3 id="30：第一次尝试LeetCode周赛，没想到又败在数论上了，明天整理一下笔记"><a href="#30：第一次尝试LeetCode周赛，没想到又败在数论上了，明天整理一下笔记" class="headerlink" title="30：第一次尝试LeetCode周赛，没想到又败在数论上了，明天整理一下笔记"></a>30：第一次尝试LeetCode周赛，没想到又败在数论上了，明天整理一下笔记</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-30.png" alt="1-30"></p>
<h3 id="29：复习半天基本算法，余下的时间有些不够用"><a href="#29：复习半天基本算法，余下的时间有些不够用" class="headerlink" title="29：复习半天基本算法，余下的时间有些不够用"></a>29：复习半天基本算法，余下的时间有些不够用</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-29.png" alt="1-29"></p>
<h3 id="28：明天准备集中复习一下基础算法，任务变动一下"><a href="#28：明天准备集中复习一下基础算法，任务变动一下" class="headerlink" title="28：明天准备集中复习一下基础算法，任务变动一下"></a>28：明天准备集中复习一下基础算法，任务变动一下</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-28.png" alt="1-28"></p>
<h3 id="27：其实把握好每个任务的优先度，效率就能提高"><a href="#27：其实把握好每个任务的优先度，效率就能提高" class="headerlink" title="27：其实把握好每个任务的优先度，效率就能提高"></a>27：其实把握好每个任务的优先度，效率就能提高</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-27.png" alt="1-27"></p>
<h3 id="26：今天小摸鱼，内容质量不高"><a href="#26：今天小摸鱼，内容质量不高" class="headerlink" title="26：今天小摸鱼，内容质量不高"></a>26：今天小摸鱼，内容质量不高</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-26.png" alt="1-26"></p>
<h3 id="25：今天稍微放松了一下，昨天的Flag又G了，任务虽然完成了但是质量不是很高"><a href="#25：今天稍微放松了一下，昨天的Flag又G了，任务虽然完成了但是质量不是很高" class="headerlink" title="25：今天稍微放松了一下，昨天的Flag又G了，任务虽然完成了但是质量不是很高"></a>25：今天稍微放松了一下，昨天的Flag又G了，任务虽然完成了但是质量不是很高</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-25.png" alt="1-25"></p>
<h3 id="24-感觉要给Vulkan多留点时间了"><a href="#24-感觉要给Vulkan多留点时间了" class="headerlink" title="24:感觉要给Vulkan多留点时间了"></a>24:感觉要给Vulkan多留点时间了</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-24.png" alt="1-24"></p>
<h3 id="23：有些极限，感觉还是需要对计划调整，现在给专业课留的学习时间有点少"><a href="#23：有些极限，感觉还是需要对计划调整，现在给专业课留的学习时间有点少" class="headerlink" title="23：有些极限，感觉还是需要对计划调整，现在给专业课留的学习时间有点少"></a>23：有些极限，感觉还是需要对计划调整，现在给专业课留的学习时间有点少</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-23.png" alt="1-23"></p>
<h3 id="22-准备学Anki先（磨刀不误砍柴工）提高语言学习效率，给其他内容留时间"><a href="#22-准备学Anki先（磨刀不误砍柴工）提高语言学习效率，给其他内容留时间" class="headerlink" title="22:准备学Anki先（磨刀不误砍柴工）提高语言学习效率，给其他内容留时间"></a>22:准备学Anki先（磨刀不误砍柴工）提高语言学习效率，给其他内容留时间</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-22.png" alt="1-22"></p>
<h3 id="21-LeetCode每日一题上头了导致好多项任务没做完QAQ，用DP解半天，最后看题解才发现这题普通DP做不了，还是我太菜了"><a href="#21-LeetCode每日一题上头了导致好多项任务没做完QAQ，用DP解半天，最后看题解才发现这题普通DP做不了，还是我太菜了" class="headerlink" title="21:LeetCode每日一题上头了导致好多项任务没做完QAQ，用DP解半天，最后看题解才发现这题普通DP做不了，还是我太菜了"></a>21:LeetCode每日一题上头了导致好多项任务没做完QAQ，用DP解半天，最后看题解才发现这题普通DP做不了，还是我太菜了</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-21.png" alt="1-21"></p>
<h3 id="20：下午打了一会游戏Vulkan暂缓一天，明天开始调整计划，英语模块将结合扇贝-app"><a href="#20：下午打了一会游戏Vulkan暂缓一天，明天开始调整计划，英语模块将结合扇贝-app" class="headerlink" title="20：下午打了一会游戏Vulkan暂缓一天，明天开始调整计划，英语模块将结合扇贝.app"></a>20：下午打了一会游戏Vulkan暂缓一天，明天开始调整计划，英语模块将结合扇贝.app</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-20.png" alt="1-20"></p>
<h3 id="19：状态还没找好，效率有点低，听力内容并没有完成，可能需要对计划进行微调"><a href="#19：状态还没找好，效率有点低，听力内容并没有完成，可能需要对计划进行微调" class="headerlink" title="19：状态还没找好，效率有点低，听力内容并没有完成，可能需要对计划进行微调"></a>19：状态还没找好，效率有点低，听力内容并没有完成，可能需要对计划进行微调</h3><p><img src="http://image.codebooklet.com/img_blog/Daily/default/1-19.png" alt="1-19"></p>
]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title>C++DeBUG记录</title>
    <url>/2021/10/31/DeBug/C++DeBUG%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><strong>记录在使用C++时与各种BUG斗智斗勇的血泪史</strong></p>
<span id="more"></span>
<h2 id="Error-C2528-’name’-pointer-to-reference-is-illegal"><a href="#Error-C2528-’name’-pointer-to-reference-is-illegal" class="headerlink" title="Error C2528:’name’ : pointer to reference is illegal"></a>Error C2528:’name’ : pointer to reference is illegal</h2><h3 id="BUG产生"><a href="#BUG产生" class="headerlink" title="BUG产生"></a>BUG产生</h3><ul>
<li>在 vector 中插入引用对象，比如 vector&lt;int&amp;&gt; nums</li>
</ul>
<h3 id="BUG原因"><a href="#BUG原因" class="headerlink" title="BUG原因"></a>BUG原因</h3><ul>
<li>不能向“容器”中加入“引用”（与底层实现相关，会导致迭代等异常，详情暂请另行搜索）</li>
</ul>
<h3 id="BUG解决"><a href="#BUG解决" class="headerlink" title="BUG解决"></a>BUG解决</h3><ul>
<li>比如将vector&lt; int&amp; &gt; nums改为vector&lt; int &gt; nums</li>
</ul>
<h2 id="Error-C2872-‘byte’-ambiguous-symbol"><a href="#Error-C2872-‘byte’-ambiguous-symbol" class="headerlink" title="Error C2872: ‘byte’: ambiguous symbol"></a>Error C2872: ‘byte’: ambiguous symbol</h2><h3 id="BUG产生-1"><a href="#BUG产生-1" class="headerlink" title="BUG产生"></a>BUG产生</h3><ul>
<li>对使用旧版WindowsSKD编写的代码，使用C++17标准（使用C++14标准时正常）</li>
</ul>
<h3 id="BUG原因-1"><a href="#BUG原因-1" class="headerlink" title="BUG原因"></a>BUG原因</h3><ul>
<li>旧版WindowsSKD有定义byte类型，但同时C++17也定义了std::byte类型，造成重复定义</li>
</ul>
<h3 id="BUG解决-1"><a href="#BUG解决-1" class="headerlink" title="BUG解决"></a>BUG解决</h3><ul>
<li><p>[Method.1] 添加_HAS_STD_BYTE=0宏</p>
</li>
<li><p>[Method.2]使用较低版本的C++标准（本次由于使用别人的框架因此采用该方法）</p>
</li>
<li><p><a href="https://blog.csdn.net/caimouse/article/details/106047569">参考文章</a></p>
</li>
</ul>
<blockquote>
<blockquote>
<p>We have determined that the feedback applies to another product: Windows &amp; Windows SDK. Thank you and we value your contribution to Developer Community.<br>We are working with the the Windows team to get this addressed in a future update of the SDK. In the meantime, the community comments &amp; workarounds describe the set of options available well. Thank you!<br>I’ll specifically highlight the following two items:<br>Use of the _HAS_STD_BYTE=0 macro by specifying /D_HAS_STD_BYTE=0 at the compiler command line. This effectively disables std::byte support in the STL and should address scenarios where ‘byte’ is not used in code. It should be noted that this macro will eventually be removed after the Windows SDK issues are fixed. That removal can be tracked via the Microsoft/STL GitHub repo at <a href="https://github.com/microsoft/STL/issues/204">https://github.com/microsoft/STL/issues/204</a>.<br>Avoid bringing std::byte into the global namespace (potential by ‘using namesapce std’) and reference the Windows SDK byte using ::byte and the C++ standard version using std::byte.<br>Regards,<br>Daniel Griffing, Visual C++ Compiler Front-End</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>DeBug</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2019无法打开ui文件</title>
    <url>/2021/10/31/DeBug/VS2019%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80ui%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul>
<li>使用VS2019+Qt5时，无法打开*.ui文件</li>
</ul>
<span id="more"></span>

<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ul>
<li>暂时不确定，估计有以下两个因素</li>
</ul>
<ol>
<li>与默认打开的Qt Designer版本选取有关，因为我电脑上有2个不同版本的Qt，用于编写项目的Qt版本与我之前用的不同</li>
<li>与默认打开的Qt Designer的编译器有关，项目使用MSVC2017_64，而之前我一直使用MinGW_32</li>
</ol>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ul>
<li>右键ui文件 —&gt; 点击“打开方式” —&gt; “添加”</li>
<li>选择 Qt目录下MSVC2017_64 中 bin目录下 Qt Designer 添加</li>
<li>将新添加的打开方式“设为默认值”</li>
<li><a href="https://blog.csdn.net/qq_43145926/article/details/105004762">参考文章</a></li>
</ul>
]]></content>
      <categories>
        <category>DeBug</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>TOEFL听力常见内容研究（Updating）</title>
    <url>/2022/01/18/LearnEnglish/TOEFL%E5%90%AC%E5%8A%9B%E5%B8%B8%E8%A7%81%E5%86%85%E5%AE%B9%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<ul>
<li>根据常出现的听力内容，整理分析笔记记法</li>
</ul>
<span id="more"></span>

<h1 id="基于场景的分类分析"><a href="#基于场景的分类分析" class="headerlink" title="基于场景的分类分析"></a>基于场景的分类分析</h1><h2 id="1-校园生活"><a href="#1-校园生活" class="headerlink" title="1.校园生活"></a>1.校园生活</h2><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><h4 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h4><ul>
<li>student</li>
<li>professor</li>
</ul>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>university</li>
<li>campus</li>
</ul>
<h4 id="学科"><a href="#学科" class="headerlink" title="学科"></a>学科</h4><ul>
<li>education</li>
<li>literature</li>
<li>chemistry</li>
<li>mathematics</li>
<li>agriculture</li>
<li>biology</li>
<li>psychology</li>
<li>geology / geography</li>
<li>ecology / economics</li>
<li>politics / political</li>
</ul>
<h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><h3 id="形容词-副词"><a href="#形容词-副词" class="headerlink" title="形容词 / 副词"></a>形容词 / 副词</h3><h3 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h3>]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>短语类记</title>
    <url>/2022/01/18/LearnEnglish/%E7%9F%AD%E8%AF%AD%E7%B1%BB%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>按照《日语语法新思维》的分类记忆模式，迁移到英语学习中看看效果，内容主要来自背单词过程</li>
</ul>
<span id="more"></span>

<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><table>
<thead>
<tr>
<th>短语</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>in the long run（从长远看）</td>
<td>In the long run, I guess I really don’t care</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="被……替代"><a href="#被……替代" class="headerlink" title="被……替代"></a>被……替代</h2><table>
<thead>
<tr>
<th>短语</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>give way to</td>
<td>To him , <strong>the bitterness of life has given way to sweetness</strong></td>
</tr>
<tr>
<td>a substitute for</td>
<td>You are a fine substitute for Watson</td>
</tr>
</tbody></table>
<h2 id="倾向"><a href="#倾向" class="headerlink" title="倾向"></a>倾向</h2><table>
<thead>
<tr>
<th>短语</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>tend to do</td>
<td>I tend to smell when I’m nervous</td>
</tr>
<tr>
<td>a trend towards</td>
<td>A trend towards intimacy in social networking</td>
</tr>
<tr>
<td>be prone to</td>
<td>He is prone to depression</td>
</tr>
<tr>
<td>incline to</td>
<td>I incline to the view that he is right</td>
</tr>
<tr>
<td>reach a plateau（达到平稳）</td>
<td>The birth rate reach a plateau after soaring suddently</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><table>
<thead>
<tr>
<th>短语</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>from the outset</td>
<td>from the outset , Louis was thinking big</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><table>
<thead>
<tr>
<th>短语</th>
<th>例句</th>
</tr>
</thead>
<tbody><tr>
<td>culminate in/with sth （以……告终）</td>
<td>The conference culminated in the speech by Professor Li</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Ex"><a href="#Ex" class="headerlink" title="Ex"></a>Ex</h2><ul>
<li>clam up : 闭口不言</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JLPT-N2-2016年12月真题笔记</title>
    <url>/2021/10/25/LearnJapanese/JLPT-N2-2016%E5%B9%B412%E6%9C%88%E7%9C%9F%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><strong>日语真题笔记系列，该系列的笔记至少会包括词汇部分，笔记会不断完善</strong><span id="more"></span>
<h2 id="１．語彙（ごい）"><a href="#１．語彙（ごい）" class="headerlink" title="１．語彙（ごい）"></a>１．語彙（ごい）</h2><table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">例句</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">機銃</td>
<td align="center">きじゅう</td>
<td align="center">機銃は機関銃と同じです</td>
<td align="center">机关枪</td>
</tr>
<tr>
<td align="center">貴重</td>
<td align="center">きちょう</td>
<td align="center">貴重な体験</td>
<td align="center">贵重，珍贵</td>
</tr>
<tr>
<td align="center">吉兆</td>
<td align="center">きっちょう</td>
<td align="center">吉兆かそれとも凶兆（きょうちょう）か</td>
<td align="center">吉兆</td>
</tr>
<tr>
<td align="center">虚しい</td>
<td align="center">むなしい</td>
<td align="center">時が虚しく過ぎる</td>
<td align="center">空虚，空洞</td>
</tr>
<tr>
<td align="center">可笑しい</td>
<td align="center">おかしい</td>
<td align="center">この漫画は実におかしい</td>
<td align="center">可笑的，奇怪的</td>
</tr>
<tr>
<td align="center">怪しい</td>
<td align="center">あやしい</td>
<td align="center">そのニュースは根拠が怪しい</td>
<td align="center">可疑的，不可靠的</td>
</tr>
<tr>
<td align="center">悔しい</td>
<td align="center">くやしい</td>
<td align="center">やつにばかにされたと思うとじつに悔しい</td>
<td align="center">懊悔，遗憾，气愤</td>
</tr>
<tr>
<td align="center">良し</td>
<td align="center">よし</td>
<td align="center">良し、やろう</td>
<td align="center">好，行，可以</td>
</tr>
<tr>
<td align="center">容姿</td>
<td align="center">ようし</td>
<td align="center">容姿端麗（たんれい）な女性</td>
<td align="center">容貌姿态</td>
</tr>
<tr>
<td align="center">様子</td>
<td align="center">ようす</td>
<td align="center">様子を探る（さぐる）</td>
<td align="center">情况，样子，迹象</td>
</tr>
<tr>
<td align="center">止す</td>
<td align="center">よす</td>
<td align="center">本を読み止す</td>
<td align="center">中止，停下</td>
</tr>
<tr>
<td align="center">払う</td>
<td align="center">はらう</td>
<td align="center">最善の努力を払う<br/>着物のすその雪を払う<br/>古本を屑屋（くずや）に払う</td>
<td align="center">支付，除掉，卖掉<br/>掸，横扫</td>
</tr>
<tr>
<td align="center">扱う</td>
<td align="center">あつかう</td>
<td align="center">客として扱う<br/>この事件は扱いやすい<br/>この自動車は扱いにくい<br/>高級品を扱っております</td>
<td align="center">对待，处理，操纵<br/>经营，报道</td>
</tr>
<tr>
<td align="center">伴う</td>
<td align="center">ともなう</td>
<td align="center">その手術には多少の危険が伴う<br/>名実相（あい）伴う</td>
<td align="center">伴随，相符</td>
</tr>
<tr>
<td align="center">救う</td>
<td align="center">すくう</td>
<td align="center">命を救う</td>
<td align="center">拯救</td>
</tr>
<tr>
<td align="center">願望</td>
<td align="center">がんぼう</td>
<td align="center">願望が叶う &lt;如愿以偿&gt;</td>
<td align="center">愿望</td>
</tr>
<tr>
<td align="center">原簿</td>
<td align="center">げんぼ</td>
<td align="center">戸籍（こせき）原簿</td>
<td align="center">底帐，原始文件</td>
</tr>
<tr>
<td align="center">招く</td>
<td align="center">まねく</td>
<td align="center">招かざる客 &lt;不速之客&gt;</td>
<td align="center">招呼，招致，宴请</td>
</tr>
<tr>
<td align="center">保証</td>
<td align="center">ほしょう</td>
<td align="center">保証金を納（おさ）める</td>
<td align="center">保证</td>
</tr>
<tr>
<td align="center">補正</td>
<td align="center">ほせい</td>
<td align="center">誤差（ごさ）の補正</td>
<td align="center">补充改正</td>
</tr>
<tr>
<td align="center">催し</td>
<td align="center">もよおし</td>
<td align="center">中日友好協会の催しで歓迎会が開かれた</td>
<td align="center">筹划，计划，举办</td>
</tr>
<tr>
<td align="center">硬貨</td>
<td align="center">こうか</td>
<td align="center">日本の硬貨</td>
<td align="center">金属货币</td>
</tr>
<tr>
<td align="center">製造</td>
<td align="center">せいぞう</td>
<td align="center">原料を加工して商品を製造する</td>
<td align="center">制造</td>
</tr>
<tr>
<td align="center">観</td>
<td align="center">かん</td>
<td align="center">人生観（じんせいかん）</td>
<td align="center">观念，想法</td>
</tr>
<tr>
<td align="center">識</td>
<td align="center">しき</td>
<td align="center">有識者（ゆうしきしゃ）</td>
<td align="center">见识，认识</td>
</tr>
<tr>
<td align="center">念</td>
<td align="center">ねん</td>
<td align="center">増悪の念（ぞうあくのねん）</td>
<td align="center">念头</td>
</tr>
<tr>
<td align="center">頂</td>
<td align="center">ちょう</td>
<td align="center">山頂（さんちょう）</td>
<td align="center">高地，巅峰</td>
</tr>
<tr>
<td align="center">上</td>
<td align="center">じょう</td>
<td align="center">上位（じょうい）</td>
<td align="center">上位</td>
</tr>
<tr>
<td align="center">高</td>
<td align="center">こう</td>
<td align="center">高品質（こうひんしつ）</td>
<td align="center">价值、品质高</td>
</tr>
<tr>
<td align="center">特</td>
<td align="center">とく</td>
<td align="center">特色（とくいろ）</td>
<td align="center">与其他不同</td>
</tr>
<tr>
<td align="center">状</td>
<td align="center">じょう</td>
<td align="center">液状（えきじょう）</td>
<td align="center">事务的形态</td>
</tr>
<tr>
<td align="center">類</td>
<td align="center">るい</td>
<td align="center">霊長類（れいちょうるい）</td>
<td align="center">分类、类别</td>
</tr>
<tr>
<td align="center">式</td>
<td align="center">しき</td>
<td align="center">中国式（ちゅうごくしき）</td>
<td align="center">方式、形式</td>
</tr>
<tr>
<td align="center">則</td>
<td align="center">そく</td>
<td align="center">法則（ほうそく）</td>
<td align="center">规则</td>
</tr>
<tr>
<td align="center">外</td>
<td align="center">がい</td>
<td align="center">時間外（じかんがい）</td>
<td align="center">范围之外</td>
</tr>
<tr>
<td align="center">否</td>
<td align="center">ひ</td>
<td align="center">否定（ひてい）</td>
<td align="center">不赞成，不承认</td>
</tr>
<tr>
<td align="center">前</td>
<td align="center">ぜん</td>
<td align="center">前世紀（ぜんせいき）</td>
<td align="center">之前的</td>
</tr>
<tr>
<td align="center">未</td>
<td align="center">み</td>
<td align="center">未承認（みしょうにん）</td>
<td align="center">尚未</td>
</tr>
<tr>
<td align="center">漬ける</td>
<td align="center">づける</td>
<td align="center">受験生なので、勉強漬けの毎日だ</td>
<td align="center">沉浸，浸泡</td>
</tr>
<tr>
<td align="center">浸す</td>
<td align="center">ひたす</td>
<td align="center">手ぬぐいを水に浸す</td>
<td align="center">把物体放进液体中</td>
</tr>
<tr>
<td align="center">溶ける</td>
<td align="center">とける</td>
<td align="center">口に入れると溶ける</td>
<td align="center">溶化，熔化</td>
</tr>
<tr>
<td align="center">満つ</td>
<td align="center">みつ</td>
<td align="center">人口4万に満たない市</td>
<td align="center">满</td>
</tr>
<tr>
<td align="center">選出</td>
<td align="center">せんしゅつ</td>
<td align="center">委員を選出する</td>
<td align="center">选出，选拔</td>
</tr>
<tr>
<td align="center">提供</td>
<td align="center">ていきょう</td>
<td align="center">安価に提供する</td>
<td align="center">提供，供给</td>
</tr>
<tr>
<td align="center">指示</td>
<td align="center">しじ</td>
<td align="center">指示を与える</td>
<td align="center">指示</td>
</tr>
<tr>
<td align="center">寄付</td>
<td align="center">きふ</td>
<td align="center">応分（おうぶん）の寄付をする</td>
<td align="center">捐献，赠给</td>
</tr>
<tr>
<td align="center">ぐったり</td>
<td align="center"></td>
<td align="center">ぐったり疲れる</td>
<td align="center">精疲力尽</td>
</tr>
<tr>
<td align="center">確り</td>
<td align="center">しっかり</td>
<td align="center">気を確りともて &lt;振作起来&gt;</td>
<td align="center">结实，牢固，行情看涨</td>
</tr>
<tr>
<td align="center">すっきり</td>
<td align="center"></td>
<td align="center">頭がすっきりする</td>
<td align="center">舒畅，简约</td>
</tr>
<tr>
<td align="center">ぎっしり</td>
<td align="center"></td>
<td align="center">ぎっしり詰まったスケジュール</td>
<td align="center">满满的</td>
</tr>
<tr>
<td align="center">面倒</td>
<td align="center">めんどう</td>
<td align="center">事件が面倒になってきた<br/>彼は面倒見がよい</td>
<td align="center">麻烦，棘手，照料</td>
</tr>
<tr>
<td align="center">邪魔</td>
<td align="center">じゃま</td>
<td align="center">邪魔な物を退（ど）かしなさい</td>
<td align="center">妨碍，打搅，累赘</td>
</tr>
<tr>
<td align="center">被害</td>
<td align="center">ひがい</td>
<td align="center">被害を見積もる &lt;估计灾害的损失&gt;</td>
<td align="center">受灾，损失</td>
</tr>
<tr>
<td align="center">無理</td>
<td align="center">むり</td>
<td align="center">無理を言う &lt;不讲理，难为&gt;<br/>いまは無理だ</td>
<td align="center">不讲理,难以办到</td>
</tr>
<tr>
<td align="center">アウト</td>
<td align="center">out</td>
<td align="center">彼のサーブ（serve）はアウトになった</td>
<td align="center">界外球出局</td>
</tr>
<tr>
<td align="center">ダウン</td>
<td align="center">down</td>
<td align="center">ダウンジャケット（down jacket）</td>
<td align="center">落下，降落</td>
</tr>
<tr>
<td align="center">ショック</td>
<td align="center">shock</td>
<td align="center">私はショックを受けました</td>
<td align="center">冲击，打击，休克</td>
</tr>
<tr>
<td align="center">エラー</td>
<td align="center">error</td>
<td align="center">エラーをする</td>
<td align="center">错误，失策</td>
</tr>
<tr>
<td align="center">大人しい</td>
<td align="center">おとなしい</td>
<td align="center">大人しい子供<br/>大人しい色</td>
<td align="center">老实，温顺，雅致</td>
</tr>
<tr>
<td align="center">細やか</td>
<td align="center">ささやか</td>
<td align="center">細やかな交誼<br/>細やかな味わい</td>
<td align="center">浓厚，细腻，深厚</td>
</tr>
<tr>
<td align="center">傾らか</td>
<td align="center">なだらか</td>
<td align="center">交渉がなだらかに進む</td>
<td align="center">平緩，平稳</td>
</tr>
<tr>
<td align="center">弱弱しい</td>
<td align="center">よわよわしい</td>
<td align="center">弱弱しい体（からだ）つき &lt;体格弱小&gt;</td>
<td align="center">孱弱，软弱</td>
</tr>
<tr>
<td align="center">活発</td>
<td align="center">かっぱつ</td>
<td align="center">クラブ活動が活発である</td>
<td align="center">活泼，活跃</td>
</tr>
<tr>
<td align="center">円満</td>
<td align="center">えんまん</td>
<td align="center">家庭が非常に円満である</td>
<td align="center">圆满，美满</td>
</tr>
<tr>
<td align="center">機敏</td>
<td align="center">きびん</td>
<td align="center">機敏な行動がとれない</td>
<td align="center">敏捷，麻利，机灵</td>
</tr>
<tr>
<td align="center">濃厚</td>
<td align="center">のうこう</td>
<td align="center">濃厚な化粧（けしょう）</td>
<td align="center">浓厚〔味や色などが〕</td>
</tr>
<tr>
<td align="center">当てはまる</td>
<td align="center">あてはまる</td>
<td align="center">この規則が当てはまらない場合もある</td>
<td align="center">适用，合适，恰当</td>
</tr>
<tr>
<td align="center">付け加える</td>
<td align="center">つけくわえる</td>
<td align="center">辞典の終わりに索引を付け加える</td>
<td align="center">增加，添加，附加，补充</td>
</tr>
<tr>
<td align="center">行き着く</td>
<td align="center">いきつく</td>
<td align="center">道に迷ったすえ、やっと行き着く</td>
<td align="center">走到，到达</td>
</tr>
<tr>
<td align="center">割り込む</td>
<td align="center">わりこむ</td>
<td align="center">バスを待つ行列のあいだに割り込む</td>
<td align="center">挤进，插嘴，跌破</td>
</tr>
<tr>
<td align="center">行列</td>
<td align="center">ぎょうれつ</td>
<td align="center">デモ（demonstration）の行列</td>
<td align="center">行列，队伍，矩阵</td>
</tr>
<tr>
<td align="center">面白い</td>
<td align="center">おもしろい</td>
<td align="center">面白いほど仕事が捗る</td>
<td align="center">愉快的，精彩的</td>
</tr>
<tr>
<td align="center">捗る</td>
<td align="center">ほかどる</td>
<td align="center">今月は作業がずいぶん捗った</td>
<td align="center">顺利进行</td>
</tr>
<tr>
<td align="center">おしゃれ</td>
<td align="center"></td>
<td align="center">あの人はおしゃれだ</td>
<td align="center">好打扮，好修饰，时髦</td>
</tr>
<tr>
<td align="center">親切</td>
<td align="center">しんせつ</td>
<td align="center">数々（かずかず）の親切を受ける</td>
<td align="center">亲切，恳切，好心</td>
</tr>
<tr>
<td align="center">可愛い</td>
<td align="center">かわいい</td>
<td align="center">女の子の可愛い唇</td>
<td align="center">宝贵的，讨喜的，可爱的</td>
</tr>
<tr>
<td align="center">勿体無い</td>
<td align="center">もったいない</td>
<td align="center">捨てるのはもったいない<br/>神前を汚（けが）すとは勿体無い</td>
<td align="center">太可惜，浪费，不胜惶恐</td>
</tr>
<tr>
<td align="center">情けない</td>
<td align="center">なさけない</td>
<td align="center">困った友人を見捨てるとは情けない<br/>情けない死に方をする</td>
<td align="center">无情，悲惨，可怜</td>
</tr>
<tr>
<td align="center">詰まらない</td>
<td align="center">つまらない</td>
<td align="center">詰まらない小説<br/>詰まらないものを買ってしまった<br/>盗まれては詰まらない</td>
<td align="center">无聊的，无用的，倒霉</td>
</tr>
<tr>
<td align="center">仕方ない</td>
<td align="center">しかたない</td>
<td align="center">どうにも仕方ない</td>
<td align="center">不得已，无可奈何</td>
</tr>
<tr>
<td align="center">愉快</td>
<td align="center">ゆかい</td>
<td align="center">愉快に語り合う</td>
<td align="center">愉快，快活</td>
</tr>
<tr>
<td align="center">止むを得ない</td>
<td align="center">やむをえない</td>
<td align="center">しかし止むを得ない事だ</td>
<td align="center">不得已，没办法，无奈</td>
</tr>
<tr>
<td align="center">息抜き</td>
<td align="center">いきぬき</td>
<td align="center">仕事の息抜きにお茶を飲む</td>
<td align="center">休息一会儿，歇口气</td>
</tr>
<tr>
<td align="center">ついていた</td>
<td align="center"></td>
<td align="center">今日はとてもついていた</td>
<td align="center">走运，占优势</td>
</tr>
<tr>
<td align="center">常に</td>
<td align="center">つねに</td>
<td align="center">常にあること</td>
<td align="center">时常，经常</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="２．单词的正确使用语境"><a href="#２．单词的正确使用语境" class="headerlink" title="２．单词的正确使用语境"></a>２．单词的正确使用语境</h2><ul>
<li><strong>延長</strong>（えんちょう）:　[他サ]　延长；继续，扩展；全长</li>
</ul>
<ol>
<li>悪い天候で列車が運転をやめたため、旅行の出発が三日後に<strong>延期</strong>された</li>
<li>初めの設計では２階建てだったが、３階建ての家に<strong>増築</strong>することにした</li>
<li>予定の時間内に結論が出ず、会議が１時間<strong>延長</strong>されることになった</li>
<li>電車の中で居眠りをして、降りる駅を一駅<strong>乗り過ごす</strong>してしまった</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">延期</td>
<td align="center">えんき</td>
<td align="center">延期，时间拖延</td>
</tr>
<tr>
<td align="center">増築</td>
<td align="center">ぞうちく</td>
<td align="center">增建，扩建</td>
</tr>
<tr>
<td align="center">乗り過ごす</td>
<td align="center">のりすごす</td>
<td align="center">坐过站</td>
</tr>
</tbody></table>
<ul>
<li><strong>錆びる</strong>（さびる）:　[自二]　生锈</li>
</ul>
<ol>
<li>暑いところに生ものをずっと置いておいたら、<strong>腐って</strong>臭くなった</li>
<li>昨夜（ゆうべ）は雨が相当降ったらしく、普段はきれいな川の水が<strong>溢れて</strong>濁っている</li>
<li>鉢（はち）に植えた植物に水をやるのをわすれていたら、花が<strong>萎れる</strong>しまった</li>
<li>この鉄の棒はずっと家の外に置いてあったので、<strong>錆びて</strong>茶色くなっている</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">腐る</td>
<td align="center">くさる</td>
<td align="center">腐败，变质</td>
</tr>
<tr>
<td align="center">溢れる</td>
<td align="center">あふれる</td>
<td align="center">溢出</td>
</tr>
<tr>
<td align="center">萎れる</td>
<td align="center">しおれる</td>
<td align="center">枯萎</td>
</tr>
<tr>
<td align="center">濁る</td>
<td align="center">にごる</td>
<td align="center">浑浊</td>
</tr>
<tr>
<td align="center">植物</td>
<td align="center">しょくぶつ</td>
<td align="center">植物</td>
</tr>
</tbody></table>
<ul>
<li><strong>目上</strong>（めうえ）:　[名]　上司，长辈</li>
</ul>
<ol>
<li>勉強会に参加した社員がすべて<strong>目上</strong>だったので、新人の私はとても緊張した</li>
<li>この店で一番値段が高く<strong>高級</strong>の商品は、店の奥にある棚に並べられていた</li>
<li>高校時代、鈴木さんはとても優秀で、成績はいつも学年で<strong>上位</strong>だつた</li>
<li>あの若さで金賞を受賞（じゅしょう）した伊藤さんは、本当に<strong>優秀</strong>の人だと思う</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高級</td>
<td align="center">こうきゅう</td>
<td align="center">高级，质量高，程度高，水平高</td>
</tr>
<tr>
<td align="center">上位</td>
<td align="center">じょうい</td>
<td align="center">等级高、水平高</td>
</tr>
<tr>
<td align="center">優秀</td>
<td align="center">ゆうしゅう</td>
<td align="center">优秀</td>
</tr>
</tbody></table>
<ul>
<li><strong>大げさ</strong>（おおげさ）:　[名|形容动词]　夸大，夸张，小题大做</li>
</ul>
<ol>
<li>息子の誕生日に料理を作りすぎてしまい、<strong>たくさん</strong>に余ってしまった</li>
<li>天気予報によると、明日は今日より<strong>めっきり</strong>に気温が下がるらしい</li>
<li>努力（どりょく）した結果、試験の成績が<strong>大幅</strong>に伸びて、先生に褒められた</li>
<li>あの人は小さいなことを<strong>大げさ</strong>に言うので、そのまま信じないほうがいい</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">たくさん</td>
<td align="center"></td>
<td align="center">许多，量大</td>
</tr>
<tr>
<td align="center">めっきり</td>
<td align="center"></td>
<td align="center">显著，明显</td>
</tr>
<tr>
<td align="center">大幅</td>
<td align="center">おおはば</td>
<td align="center">大幅度</td>
</tr>
</tbody></table>
<ul>
<li><strong>反省</strong>（はんせい）:　[他サ]　自我反省</li>
</ul>
<ol>
<li>発表の原稿を全部覚えたのに、緊張のせいでどんなに<strong>努力</strong>しても全く思い出せない</li>
<li>今回の企画では、私の準備不足で回りに迷惑をかけたことをしても<strong>反省</strong>しています</li>
<li>祖父（そふ）はいつも若いころの思い出を懐かしそうに<strong>振り返</strong>して私に話してくれる</li>
<li>この機械の使い方を忘れないように、もう一度最初から<strong>お浚い</strong>しておきましょう</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">努力</td>
<td align="center">どりょく</td>
<td align="center">努力</td>
</tr>
<tr>
<td align="center">振り返る</td>
<td align="center">ふりかえる</td>
<td align="center">回忆，回顾</td>
</tr>
<tr>
<td align="center">お浚い</td>
<td align="center">おさらい</td>
<td align="center">温习，复习</td>
</tr>
<tr>
<td align="center">発表</td>
<td align="center">はっぴょう</td>
<td align="center">发表</td>
</tr>
<tr>
<td align="center">最初</td>
<td align="center">さいしょ</td>
<td align="center">最初</td>
</tr>
<tr>
<td align="center">最中</td>
<td align="center">さいちゅう</td>
<td align="center">正在…的时候</td>
</tr>
<tr>
<td align="center">最終</td>
<td align="center">さいしゅう</td>
<td align="center">最后</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>日语学习</category>
      </categories>
      <tags>
        <tag>日语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmatrix与Shell实现随机屏保</title>
    <url>/2021/11/08/Linux/Cmatrix%E4%B8%8EShell%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%B1%8F%E4%BF%9D/</url>
    <content><![CDATA[<ul>
<li>使用简单的ShellScript与Cmatrix在Ubuntu系统中实现“<strong>黑客帝国风屏保</strong>”</li>
</ul>
<span id="more"></span>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://image.codebooklet.com/img_blog/Linux/cmatrix.gif"></p>
<h2 id="Step1-安装cmatrix"><a href="#Step1-安装cmatrix" class="headerlink" title="Step1. 安装cmatrix"></a>Step1. 安装cmatrix</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get-install cmatrix</span><br></pre></td></tr></table></figure>
<ul>
<li>然后可以输入命令“cmatrix”测试是否安装成功</li>
</ul>
<h2 id="Step2-编写ShellScript"><a href="#Step2-编写ShellScript" class="headerlink" title="Step2. 编写ShellScript"></a>Step2. 编写ShellScript</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ScreenSaver.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# == 1 ]</span><br><span class="line">then cmatrix -s -b -C $1 #这里设置可以手动输入颜色</span><br><span class="line">else</span><br><span class="line">        randInt=$RANDOM</span><br><span class="line">        mode=$((randInt % 8))</span><br><span class="line">        if [ $mode == 0 ]</span><br><span class="line">                then cmatrix -s -b -C green</span><br><span class="line">        elif [ $mode == 1 ]</span><br><span class="line">                then cmatrix -s -b -C red</span><br><span class="line">        elif [ $mode == 2 ]</span><br><span class="line">                then cmatrix -s -b -C blue</span><br><span class="line">        elif [ $mode == 3 ]</span><br><span class="line">                then cmatrix -s -b -C white</span><br><span class="line">        elif [ $mode == 4 ]</span><br><span class="line">                then cmatrix -s -b -C yellow</span><br><span class="line">        elif [ $mode == 5 ]</span><br><span class="line">                then cmatrix -s -b -C cyan</span><br><span class="line">        elif [ $mode == 6 ]</span><br><span class="line">                then cmatrix -s -b -C magenta</span><br><span class="line">        else cmatrix -s -b -C black</span><br><span class="line">        fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x ScreenSaver.sh <span class="comment">#设置可执行权限</span></span><br><span class="line">./ScreenSaver.sh <span class="comment">#执行ShellScript</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可以使用“man cmatrix”查看更多参数，这里只说明使用过的参数</strong></li>
<li>[ -s ] ：启用 屏保(ScreenSaver) 模式，可以按任意键退出</li>
<li>[ -b ] ：启用 随机粗体 主要提升视觉效果</li>
<li>[ -C ]：设置字幕颜色，默认为green</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JLPT-N2-2017年7月真题笔记</title>
    <url>/2021/11/06/LearnJapanese/JLPT-N2-2017%E5%B9%B47%E6%9C%88%E7%9C%9F%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><strong>日语真题笔记系列，该系列的笔记至少会包括词汇部分，笔记会不断完善</strong><span id="more"></span>
<h2 id="１．語彙（ごい）"><a href="#１．語彙（ごい）" class="headerlink" title="１．語彙（ごい）"></a>１．語彙（ごい）</h2><table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">例句</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">諄い</td>
<td align="center">くどい</td>
<td align="center">くどい話　諄い味</td>
<td align="center">冗长乏味，啰嗦，油腻</td>
</tr>
<tr>
<td align="center">狡い</td>
<td align="center">ずるい</td>
<td align="center">そんなことするなんて狡い</td>
<td align="center">不讲理，狡猾，奸诈</td>
</tr>
<tr>
<td align="center">幼い</td>
<td align="center">おさない</td>
<td align="center">彼はいい年をしている割には言うことが幼い</td>
<td align="center">幼小，幼年，幼稚</td>
</tr>
<tr>
<td align="center">しつこい</td>
<td align="center"></td>
<td align="center">しつこく付きまとわれる＜被死死纠缠＞</td>
<td align="center">执拗，纠缠不休，浓艳，浓重</td>
</tr>
<tr>
<td align="center">振る</td>
<td align="center">ふる</td>
<td align="center">さいころを振る＜掷骰子＞</td>
<td align="center">挥，摇，摆</td>
</tr>
<tr>
<td align="center">握る</td>
<td align="center">にぎる</td>
<td align="center">相手の弱みを握る</td>
<td align="center">掌握，握，攥</td>
</tr>
<tr>
<td align="center">擦る</td>
<td align="center">こする</td>
<td align="center">この染みはいくら擦っても取れない</td>
<td align="center">摩擦，擦，揉搓，蹭</td>
</tr>
<tr>
<td align="center">掘る</td>
<td align="center">ほる</td>
<td align="center">井戸（いど）を掘る</td>
<td align="center">挖掘</td>
</tr>
<tr>
<td align="center">密閉</td>
<td align="center">みっぺい</td>
<td align="center">この箱は密閉してある</td>
<td align="center">密闭，严密关闭，密封</td>
</tr>
<tr>
<td align="center">絞る</td>
<td align="center">しぼる</td>
<td align="center">頭を絞る＜绞尽脑汁＞</td>
<td align="center">榨，拧，挤，绞</td>
</tr>
<tr>
<td align="center">削る</td>
<td align="center">けずる</td>
<td align="center">薄く削る・厚く削る・予算を削る</td>
<td align="center">削，削减，删减</td>
</tr>
<tr>
<td align="center">探る</td>
<td align="center">さぐる</td>
<td align="center">懐（ふところ）を探る<br/>相手の腹（はら）を探る<br/>香山の紅葉を探る<br/>河を遡って水源を探る</td>
<td align="center">刺探，试探，观赏，调查</td>
</tr>
<tr>
<td align="center">伺う</td>
<td align="center">うかがう</td>
<td align="center">いつお伺いしましょうか</td>
<td align="center">请教，打听</td>
</tr>
<tr>
<td align="center">窺う</td>
<td align="center">うかがう</td>
<td align="center">顔色を窺う・好機を窺う・内情の一端を窺う</td>
<td align="center">暗中观察，窥视，略知</td>
</tr>
<tr>
<td align="center">垂直</td>
<td align="center">すいちょく</td>
<td align="center">2線が垂直に交わる（まじわる）</td>
<td align="center">垂直</td>
</tr>
<tr>
<td align="center">凍る</td>
<td align="center">こおる</td>
<td align="center">道路はかちかちに凍っている</td>
<td align="center">结冰</td>
</tr>
<tr>
<td align="center">結ぶ</td>
<td align="center">むすぶ</td>
<td align="center">固く結ぶ・縁を結ぶ・自分の好きな言葉で文章を結んだ</td>
<td align="center">系，缔结，结尾</td>
</tr>
<tr>
<td align="center">固まる</td>
<td align="center">かたまる</td>
<td align="center">コンクリートが固まる<br/>寒いので，みんなストーブのまわりにかたまっている</td>
<td align="center">变硬，凝结，稳固，成群，固执于</td>
</tr>
<tr>
<td align="center">冷える</td>
<td align="center">ひえる</td>
<td align="center">ご飯が冷える・二人の仲が冷える</td>
<td align="center">变冷，变凉，变冷淡</td>
</tr>
<tr>
<td align="center">党論</td>
<td align="center">とうろん</td>
<td align="center"></td>
<td align="center">党论</td>
</tr>
<tr>
<td align="center">討論</td>
<td align="center">とうろん</td>
<td align="center">討論に付する・討論に入る・討論に加わる</td>
<td align="center">讨论</td>
</tr>
<tr>
<td align="center">討議</td>
<td align="center">とうぎ</td>
<td align="center">徹底的（てっていてき）に討議する</td>
<td align="center">讨论</td>
</tr>
<tr>
<td align="center">党議</td>
<td align="center">とうぎ</td>
<td align="center"></td>
<td align="center">党内的论议党的决定</td>
</tr>
<tr>
<td align="center">治る</td>
<td align="center">なおる</td>
<td align="center">治りかけの病人＜快要好的病人＞</td>
<td align="center">病医好，痊愈</td>
</tr>
<tr>
<td align="center">助ける</td>
<td align="center">たすける</td>
<td align="center">貧しい（まずしい）人を助ける</td>
<td align="center">助，援助，辅佐</td>
</tr>
<tr>
<td align="center">救う</td>
<td align="center">すくう</td>
<td align="center">貧民（ひんみん）を救う</td>
<td align="center">救，拯救，搭救，救援</td>
</tr>
<tr>
<td align="center">好調</td>
<td align="center">こうちょう</td>
<td align="center">好調なときに油断するな＜顺利时不可疏忽大意＞</td>
<td align="center">顺利，情况良好</td>
</tr>
<tr>
<td align="center">快調</td>
<td align="center">かいちょう</td>
<td align="center">きょうは快調だ＜今天精神很好＞</td>
<td align="center">情况良好，精神好</td>
</tr>
<tr>
<td align="center">延久</td>
<td align="center">えんきゅう</td>
<td align="center">延久時代（1069年5月6日~1074年9月16日）</td>
<td align="center">延久（年号）</td>
</tr>
<tr>
<td align="center">永遠</td>
<td align="center">えいえん</td>
<td align="center">永遠の真理（しんり）</td>
<td align="center">永远，永久，永恒</td>
</tr>
<tr>
<td align="center">永久</td>
<td align="center">えいきゅう</td>
<td align="center">永久に続く＜万古长青＞</td>
<td align="center">永久，永远，恒久</td>
</tr>
<tr>
<td align="center">発</td>
<td align="center">はつ</td>
<td align="center">東京発</td>
<td align="center">始发地，出发点</td>
</tr>
<tr>
<td align="center">開</td>
<td align="center">かい</td>
<td align="center">開店（閉店へいてん）</td>
<td align="center">开始</td>
</tr>
<tr>
<td align="center">頭</td>
<td align="center">とう</td>
<td align="center">頭取（とうどり）＜行长，董事长，总经理＞</td>
<td align="center">脑袋，头领</td>
</tr>
<tr>
<td align="center">初</td>
<td align="center">しょ</td>
<td align="center">初対面（しょたいめん）</td>
<td align="center">初始，起始</td>
</tr>
<tr>
<td align="center">先</td>
<td align="center">せん</td>
<td align="center">先君子（せんくんし）＜先帝＞</td>
<td align="center">已故的</td>
</tr>
<tr>
<td align="center">前</td>
<td align="center">ぜん</td>
<td align="center">前首相（ぜんしゅしょう）</td>
<td align="center">上一次的</td>
</tr>
<tr>
<td align="center">昨</td>
<td align="center">さく</td>
<td align="center">昨日・昨年・昨１５日</td>
<td align="center">接在时间前表上一个</td>
</tr>
<tr>
<td align="center">去</td>
<td align="center">きょ</td>
<td align="center">去年</td>
<td align="center">时间上已经过去的</td>
</tr>
<tr>
<td align="center">令</td>
<td align="center">れい</td>
<td align="center">令息（れいそく）・令嬢（れいじょう）</td>
<td align="center">尊称的前缀</td>
</tr>
<tr>
<td align="center">制</td>
<td align="center">せい</td>
<td align="center">律令制（りつりょうせい）＜奈良、平安时代的法令＞</td>
<td align="center">制度</td>
</tr>
<tr>
<td align="center">則</td>
<td align="center">そく</td>
<td align="center">経験（けいけん）則</td>
<td align="center">规则</td>
</tr>
<tr>
<td align="center">形</td>
<td align="center">けい</td>
<td align="center">正方形（せいほうけい）</td>
<td align="center">形状</td>
</tr>
<tr>
<td align="center">込み</td>
<td align="center">こみ</td>
<td align="center">税込み</td>
<td align="center">〇包括在内，总共</td>
</tr>
<tr>
<td align="center">付き</td>
<td align="center">つき</td>
<td align="center">条件付き</td>
<td align="center">附带</td>
</tr>
<tr>
<td align="center">連れ</td>
<td align="center">づれ</td>
<td align="center">子供連れ</td>
<td align="center">带着</td>
</tr>
<tr>
<td align="center">本</td>
<td align="center">ほん</td>
<td align="center">本年度</td>
<td align="center">当前</td>
</tr>
<tr>
<td align="center">正</td>
<td align="center">せい</td>
<td align="center">正社員</td>
<td align="center">正式的</td>
</tr>
<tr>
<td align="center">真</td>
<td align="center">ま</td>
<td align="center">真冬・真横</td>
<td align="center">正好，没有倾斜</td>
</tr>
<tr>
<td align="center">完</td>
<td align="center">かん</td>
<td align="center">完済（かんさい）＜还清＞<br />完治（かんじ）＜痊愈＞</td>
<td align="center">完全</td>
</tr>
<tr>
<td align="center">豊富</td>
<td align="center">ほうふ</td>
<td align="center">内容が極めて（きわめて）豊富だ()</td>
<td align="center">丰富，富有</td>
</tr>
<tr>
<td align="center">活発</td>
<td align="center">かっぱつ</td>
<td align="center">議論が活発に行われている</td>
<td align="center">活泼，活跃</td>
</tr>
<tr>
<td align="center">円満</td>
<td align="center">えんまん</td>
<td align="center">円満具足（ぐそく）＜万事俱备＞</td>
<td align="center">圆满，美满</td>
</tr>
<tr>
<td align="center">鮮明</td>
<td align="center">せんめい</td>
<td align="center">鮮明なコントラスト（contrast）を形成</td>
<td align="center">鲜明，清晰，清楚</td>
</tr>
<tr>
<td align="center">柔らかい</td>
<td align="center">やわらかい</td>
<td align="center">柔らかい日差し（ひざし）<br/>頭が柔らかい</td>
<td align="center">柔软，柔和，温柔，灵活</td>
</tr>
<tr>
<td align="center">穏やかな</td>
<td align="center">おだやかな</td>
<td align="center">穏やかな海<br/>穏やかに暮らす<br/>そんな措置（そち）を採る（とる）のは穏やかでない</td>
<td align="center">平稳，稳静，温和，妥当</td>
</tr>
<tr>
<td align="center">滑らかな</td>
<td align="center">なめらかな</td>
<td align="center">滑らかな肌（はだ）<br/>滑らかな話しぶり＜口齿伶俐＞<br/>事が滑らかに運ぶ</td>
<td align="center">光滑，说话流利，文章通顺，事情顺利</td>
</tr>
<tr>
<td align="center">緩やかな</td>
<td align="center">ゆるやかな</td>
<td align="center">緩やかな流れ＜缓慢的河流＞<br/>審査基準（しんさきじゅん）を緩やかにする<br/>緩やかな気分</td>
<td align="center">缓慢，缓和，宽松，舒畅</td>
</tr>
<tr>
<td align="center">制作</td>
<td align="center">せいさく</td>
<td align="center">芸術作品（げいじゅつさくひん）を制作する</td>
<td align="center">创作（多用于动画、美术等）</td>
</tr>
<tr>
<td align="center">保存</td>
<td align="center">ほぞん</td>
<td align="center">領収書を保存する＜保存发票＞</td>
<td align="center">保存</td>
</tr>
<tr>
<td align="center">作成</td>
<td align="center">さくせい</td>
<td align="center">書類の作成を依頼する＜拜托拟定文件＞</td>
<td align="center">制作，制定（多用于文件、计划等）</td>
</tr>
<tr>
<td align="center">確保</td>
<td align="center">かくほ</td>
<td align="center">食糧の確保に努める</td>
<td align="center">确保</td>
</tr>
<tr>
<td align="center">アピール</td>
<td align="center">appeal</td>
<td align="center">原水爆（げんすいばく）禁止のアピール<br/>広く世間にアピールする<br/>セックスのアピール</td>
<td align="center">呼吁，控诉，魅力</td>
</tr>
<tr>
<td align="center">インストール</td>
<td align="center">install</td>
<td align="center">ソフトウェアをインストールする</td>
<td align="center">装置，安装</td>
</tr>
<tr>
<td align="center">チャージ</td>
<td align="center">charge</td>
<td align="center">ルームチャージ＜房租＞<br/>テーブルチャージ＜桌位费＞</td>
<td align="center">冲撞，上油，加油，装子弹，收费，索价</td>
</tr>
<tr>
<td align="center">セット</td>
<td align="center">set</td>
<td align="center">コーヒー・セット＜一套咖啡器皿＞<br/>セットしてください＜请给我做头发＞<br/>会見をセットする</td>
<td align="center">一套，一局，梳整发形，布置，安排</td>
</tr>
<tr>
<td align="center">断る</td>
<td align="center">ことわる</td>
<td align="center">前もって断っておく＜预先通知一下＞<br/>誰にも断らずに入ってくる<br/>一応事前に断ってください＜请事先说一声＞<br/>きっぱり断る＜断然拒绝＞</td>
<td align="center">预先通知，事前请示，拒绝，推辞</td>
</tr>
<tr>
<td align="center">疑う</td>
<td align="center">うたがう</td>
<td align="center">これは些か（いささか）も疑う余（よ）地がない<br/>彼はスパイ（spy）ではないかと疑われている</td>
<td align="center">怀疑，疑惑，猜测</td>
</tr>
<tr>
<td align="center">悔やむ</td>
<td align="center">くやむ</td>
<td align="center">すんだことを悔やんでも取り返し＜挽回＞はつかない<br/>彼の早死（はやじ）にを悔やむ＜哀悼他英年早逝＞</td>
<td align="center">懊悔，后悔，吊唁，哀悼</td>
</tr>
<tr>
<td align="center">諦める</td>
<td align="center">あきらめる</td>
<td align="center">こればかりはあきらめない＜唯有这一点还不能死心＞<br/>彼をあきらめきれない＜舍不得他＞</td>
<td align="center">断念，死心，罢手，看开</td>
</tr>
<tr>
<td align="center">契機</td>
<td align="center">けいき</td>
<td align="center">病気を契機に酒をやめる</td>
<td align="center">契机，转机，动机，起因</td>
</tr>
<tr>
<td align="center">先端</td>
<td align="center">せんたん</td>
<td align="center">防波堤（ぼうはてい）の先端<br/>三日月（みかづき）の先端＜月牙尖儿＞</td>
<td align="center">顶端，（时代的）尖端，先锋</td>
</tr>
<tr>
<td align="center">始発</td>
<td align="center">しはつ</td>
<td align="center">大阪始発の急行・始発駅＜起点站＞</td>
<td align="center">乗り物の運転区間の最初場所</td>
</tr>
<tr>
<td align="center">合図</td>
<td align="center">あいず</td>
<td align="center">目で合図する＜使眼色＞</td>
<td align="center">信号，暗号</td>
</tr>
<tr>
<td align="center">ぐっすり</td>
<td align="center"></td>
<td align="center">ぐっすり寝入る<br/>泥濘（でいねい）へぐっすり片足を踏み込み</td>
<td align="center">睡眠香甜，实实在在地</td>
</tr>
<tr>
<td align="center">うろうろ</td>
<td align="center"></td>
<td align="center">うろうろと歩き回る</td>
<td align="center">彷徨，徘徊，转来转去，心神不安</td>
</tr>
<tr>
<td align="center">ひそひそ</td>
<td align="center"></td>
<td align="center">小声でひそひそと話す<br/>わたしに隠れてひそひそと相談するな</td>
<td align="center">偸偸，悄悄，暗中</td>
</tr>
<tr>
<td align="center">ばっさり</td>
<td align="center"></td>
<td align="center">長い髪をばっさり（と）切ってしまう</td>
<td align="center">痛快地，决断地斩断</td>
</tr>
<tr>
<td align="center">汚れる</td>
<td align="center">よごれる</td>
<td align="center">汚れた金を受け取るな</br>汚れた一生</td>
<td align="center">污染，失去贞操</td>
</tr>
<tr>
<td align="center">汚す</td>
<td align="center">けがす</td>
<td align="center">幼児（ようじ）の純真な心を汚す</br>国家の体面を汚す</td>
<td align="center">玷辱，污染，凌辱</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="２．单词的正确使用语境"><a href="#２．单词的正确使用语境" class="headerlink" title="２．单词的正确使用语境"></a>２．单词的正确使用语境</h2><ul>
<li><strong>頂上</strong>（ちょうじょう）:　[名]　顶峰，山顶，极点</li>
</ul>
<ol>
<li>この星は、夏の夜１２時ごろ、空の<strong>果て</strong>のあたりに見える</li>
<li>山に登り始めて５時間ぐらいして、ようやく<strong>頂上</strong>に着いた</li>
<li>この家の２階の部屋は、<strong>屋上</strong>にも窓が付いているので、とても明るい</li>
<li>本棚がいっぱいになってしまい、本棚の<strong>棚上</strong>にも本を置いている</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">果て</td>
<td align="center">はて</td>
<td align="center">边际，尽头，止境</td>
</tr>
<tr>
<td align="center">屋上</td>
<td align="center">おくじょう</td>
<td align="center">屋顶上</td>
</tr>
<tr>
<td align="center">棚上</td>
<td align="center">たなうえ</td>
<td align="center">书架的顶上</td>
</tr>
</tbody></table>
<ul>
<li><strong>節約</strong>（せつやく）:　[名]　节约,节省</li>
</ul>
<ol>
<li>駅に向かう道路の渋滞を<strong>緩和</strong>するため、道の幅を広げる工事が行われている</li>
<li>美術館の中は、カビが発生（はっせい）して絵がい傷まないように、温度や湿度を<strong>調節</strong>しています</li>
<li>試験が近くなってきたので、アルバイトの仕事を少し<strong>減らす</strong>することにした</li>
<li>私の会社では、紙や郵送費を<strong>節約</strong>するため、資料はすべてメールで送っている</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">緩和</td>
<td align="center">かんわ</td>
<td align="center">缓和，缓解</td>
</tr>
<tr>
<td align="center">調節</td>
<td align="center">ちょうせつ</td>
<td align="center">调节</td>
</tr>
<tr>
<td align="center">減らす</td>
<td align="center">へらす</td>
<td align="center">减少</td>
</tr>
<tr>
<td align="center">カビ</td>
<td align="center">かび</td>
<td align="center">霉</td>
</tr>
<tr>
<td align="center">湿度</td>
<td align="center">しつど</td>
<td align="center">しつど</td>
</tr>
<tr>
<td align="center">傷む</td>
<td align="center">いたむ</td>
<td align="center">腐败，损坏</td>
</tr>
</tbody></table>
<ul>
<li><strong>分解</strong>（ぶんかい）:　[名・自他・三类]　拆开，分解<strong>（个人认为是指可以由小部件构成的物体才可用分解）</strong></li>
</ul>
<ol>
<li>機械の調子が悪かったので、<strong>分解</strong>して部品の点検をした</li>
<li>スイカを買ってきたが、大きくて冷蔵庫に入らなかったので、四つに<strong>分けた</strong></li>
<li>細かいお金がなかったので、近くの店で千円札を<strong>両替</strong>してもらった</li>
<li>急ぎの仕事が入ったので、三人で<strong>分担</strong>して進めることにした</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分ける</td>
<td align="center">わける</td>
<td align="center">分开，分为</td>
</tr>
<tr>
<td align="center">両替</td>
<td align="center">りょうがえ</td>
<td align="center">兑换</td>
</tr>
<tr>
<td align="center">分担</td>
<td align="center">ぶんたん</td>
<td align="center">分担，分开承担</td>
</tr>
<tr>
<td align="center">千円札</td>
<td align="center">せんえんさつ</td>
<td align="center">一千元的纸币</td>
</tr>
</tbody></table>
<ul>
<li><strong>略す</strong>（りゃくす）:　[五段活用]　省略,略去,夺取,攻略</li>
</ul>
<ol>
<li>時間がないので、詳しい説明は<strong>略して</strong>、要点だけを話しします</li>
<li>合計で一万円以上ご購入の場合、送料は<strong>省きます</strong></li>
<li>健康（けんこう）のために、砂糖（さとう）を<strong>抜いた</strong>ジャムを使っています</li>
<li>このオフィスは、壁を<strong>無くして</strong>、開放感（かいほうかん）のあるデザインにしました</li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">省く</td>
<td align="center">はぶく</td>
<td align="center">节省，节约</td>
</tr>
<tr>
<td align="center">抜く</td>
<td align="center">ぬく</td>
<td align="center">省去，省略</td>
</tr>
<tr>
<td align="center">無くす</td>
<td align="center">なくす</td>
<td align="center">清除，去除</td>
</tr>
</tbody></table>
<ul>
<li><strong>覆う</strong>（おおう）:　[他]　蒙上，包括，概括，覆盖，充满，笼罩</li>
</ul>
<ol>
<li>私のうちは、周りを高層（こうそう）マンシュンに<strong>囲まれて</strong>、日当たりが悪い</li>
<li>優勝した森選手は大勢の記者に<strong>囲まれて</strong>インタビューを受けいていた</li>
<li>公園に続く並木道はすっかり落ち葉で<strong>覆われていた</strong></li>
<li>部屋が暑いのか、中島さんの顔は汗で<strong>濡れて</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center">单词</th>
<th align="center"></th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">囲む</td>
<td align="center">かこむ</td>
<td align="center">包围，围绕</td>
</tr>
<tr>
<td align="center">濡れる</td>
<td align="center">ぬれる</td>
<td align="center">淋湿，掺入水分</td>
</tr>
<tr>
<td align="center">選手</td>
<td align="center">せんしゅ</td>
<td align="center">选手</td>
</tr>
<tr>
<td align="center">続く</td>
<td align="center">つづく</td>
<td align="center">继续，跟上，通向</td>
</tr>
<tr>
<td align="center">大勢</td>
<td align="center">おおぜい</td>
<td align="center">很多的（指人）</td>
</tr>
<tr>
<td align="center">優勝</td>
<td align="center">ゆうしょう</td>
<td align="center">第一名，优胜</td>
</tr>
<tr>
<td align="center">日当たり</td>
<td align="center">ひあたり</td>
<td align="center">光照，向阳处</td>
</tr>
<tr>
<td align="center">並木道</td>
<td align="center">なみきみち</td>
<td align="center">林荫道</td>
</tr>
<tr>
<td align="center">すっかり</td>
<td align="center"></td>
<td align="center">全都是，完全是</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>日语学习</category>
      </categories>
      <tags>
        <tag>日语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux-Ubuntu从入门到精通》笔记</title>
    <url>/2021/10/27/Linux/Linux-Ubuntu%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>该笔记仅包含书中个人认为比较重要的内容，参考书中的学习路线，但内容是结合其他资料和个人思考整合并精简化所得到</p>
<span id="more"></span>

<h1 id="Chapter4-文件系统管理"><a href="#Chapter4-文件系统管理" class="headerlink" title="Chapter4. 文件系统管理"></a>Chapter4. 文件系统管理</h1><h2 id="文件系统的基本概念"><a href="#文件系统的基本概念" class="headerlink" title="文件系统的基本概念"></a>文件系统的基本概念</h2><h3 id="1-存储介质"><a href="#1-存储介质" class="headerlink" title="1. 存储介质"></a>1. 存储介质</h3><ul>
<li>用以存储数据的物理介质</li>
</ul>
<h3 id="2-磁盘分割"><a href="#2-磁盘分割" class="headerlink" title="2. 磁盘分割"></a>2. 磁盘分割</h3><ul>
<li>对于较大存储容量的介质，需要合理规划分区</li>
</ul>
<h3 id="3-创建文件系统"><a href="#3-创建文件系统" class="headerlink" title="3. 创建文件系统"></a>3. 创建文件系统</h3><ul>
<li>即初始化，需要先进行磁盘分割才能创建文件系统</li>
</ul>
<h3 id="4-挂载"><a href="#4-挂载" class="headerlink" title="4. 挂载"></a>4. 挂载</h3><ul>
<li>Linux / Unix 系统没有磁盘分区的逻辑概念</li>
<li>任何一个文件系统被创建后都需要挂载到特定目录挂载过程相当于激活文件系统，</li>
<li>Windows系统由内部机制实现，Linux则需要使用挂载工具</li>
<li>Windows文件系统挂载：将磁盘分成若干分区，在各个分区中挂载文件系统</li>
<li>Linux文件系统挂载：将磁盘空间挂载在一个挂载点（空置的目录）</li>
</ul>
<h2 id="Ubuntu文件系统的结构"><a href="#Ubuntu文件系统的结构" class="headerlink" title="Ubuntu文件系统的结构"></a>Ubuntu文件系统的结构</h2><h3 id="1-文件系统层次化标准FHS（Filesystem-Hierarchy-Standard）"><a href="#1-文件系统层次化标准FHS（Filesystem-Hierarchy-Standard）" class="headerlink" title="1.文件系统层次化标准FHS（Filesystem Hierarchy Standard）"></a>1.文件系统层次化标准FHS（Filesystem Hierarchy Standard）</h3><ul>
<li>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件<a href="http://c.biancheng.net/view/2833.html">&gt;&gt; 参考资料</a> </li>
</ul>
<h3 id="2-根目录"><a href="#2-根目录" class="headerlink" title="2.根目录"></a>2.根目录</h3><ul>
<li>FHS 认为，Linux 系统的根目录（/）最为重要，其原因有以下 2 点：</li>
</ul>
<ol>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ol>
<ul>
<li>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件</li>
</ul>
<table>
<thead>
<tr>
<th align="center">主要一级目录</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/bin/</td>
<td align="center"><strong>存放系统命令</strong>，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td align="center">/boot/</td>
<td align="center"><strong>系统启动目录</strong>，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td>
</tr>
<tr>
<td align="center">/dev/</td>
<td align="center">设备文件保存位置</td>
</tr>
<tr>
<td align="center">/etc/</td>
<td align="center"><strong>配置文件保存位置</strong>。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td align="center">/home/</td>
<td align="center"><strong>普通用户的主目录</strong>（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录</td>
</tr>
<tr>
<td align="center">/lib/</td>
<td align="center"><strong>系统调用的函数库保存位置</strong></td>
</tr>
<tr>
<td align="center">/media/</td>
<td align="center"><strong>挂载目录</strong>。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td align="center">/mnt/</td>
<td align="center"><strong>挂载目录</strong>。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td align="center">/misc/</td>
<td align="center"><strong>挂载目录 <strong>。系统建议用来挂载 NFS 服务的共享目录。</strong>虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定</strong></td>
</tr>
<tr>
<td align="center">/opt/</td>
<td align="center">第三方安装的软件<strong>可选保存位置，比如/usr/local/ 目录也可以用来安装软件</strong>。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中</td>
</tr>
<tr>
<td align="center">/root/</td>
<td align="center">root 的主目录</td>
</tr>
<tr>
<td align="center">/sbin/</td>
<td align="center"><strong>保存与系统环境设置相关的命令</strong>，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td align="center">/srv/</td>
<td align="center"><strong>服务数据目录</strong>。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td align="center">/tmp/</td>
<td align="center"><strong>临时目录</strong>。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。<strong>建议此目录中不能保存重要数据</strong>，最好每次开机都把该目录清空</td>
</tr>
</tbody></table>
<ul>
<li><strong>FHS 针对根目录中包含的子目录仅限于上表，但Linux 根目录下通常还包含以下中的几个一级目录</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">其他一级目录</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/lost+found/</td>
<td align="center">当系统意外崩溃或意外关机时，产生的一些 <strong>文件碎片会存放在这里</strong>。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。 <strong>这个目录只在每个分区中出现</strong>，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录</td>
</tr>
<tr>
<td align="center">/proc/</td>
<td align="center"><strong>虚拟文件系统</strong>。 <strong>该目录中的数据并不保存在硬盘上，而是保存到内存中</strong>。主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的……</td>
</tr>
<tr>
<td align="center">/sys/</td>
<td align="center"><strong>虚拟文件系统</strong>。和 /proc/ 目录相似， <strong>该目录中的数据都保存在内存中，主要保存与内核相关的信息</strong></td>
</tr>
</tbody></table>
<p><font color="red">★</font> 注意/proc/和/sys/两个虚拟文件系统，数据都保存在内存中</p>
<h2 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h2><h3 id="1-交换分区的概念"><a href="#1-交换分区的概念" class="headerlink" title="1.交换分区的概念"></a>1.交换分区的概念</h3><ul>
<li>在Linux中交换分区就是“虚拟内存”技术的体现，概念上类似于Windows中的交换文件</li>
</ul>
<h3 id="2-交换分区的作用"><a href="#2-交换分区的作用" class="headerlink" title="2.交换分区的作用"></a>2.交换分区的作用</h3><ul>
<li>当数据被存放在物理内存中时，这些数据并不经常使用，或者物理内存不够用时，那么一部分数据就会转移到交换分区中，将真正需要使用内存的数据转入内存</li>
<li>并<strong>不是任何数据转移都会用到交换分区</strong>，比如写文件（内存=&gt;磁盘），读文件（内存=&gt;释放）</li>
<li>交换分区是<strong>匿名数据的交换空间</strong>，在文件系统中没有相应映射只在内存中存在的数据称为匿名数据，比如malloc、new等函数生成的对象数据、堆栈的一些状态和变量数据等，由于是在内存上进行空间操作，因此需要交换分区</li>
</ul>
<h3 id="3-交换分区对系统的影响因素"><a href="#3-交换分区对系统的影响因素" class="headerlink" title="3.交换分区对系统的影响因素"></a>3.交换分区对系统的影响因素</h3><ul>
<li>Size(交换分区) &gt;= Size(物理内存)，一般取物理内存大小的2倍及以上 </li>
<li>交换分区的数量，如果交换分区过少，会由于I/O频繁降低性能</li>
</ul>
<h3 id="4-交换分区的管理"><a href="#4-交换分区的管理" class="headerlink" title="4.交换分区的管理"></a>4.交换分区的管理</h3><ul>
<li><p>交换分区是分页管理的，页大小与内存页一致（使用”getconf PAGE_SIZE”查看内存页大小）</p>
</li>
<li><p>使用”vmstat”命令查看主要系统性能指标 （参数①：采样频率（秒），参数②：采样次数，默认1次，如果设置了①而没有设置②则无限循环）</p>
</li>
<li><p>默认输出单位为KB，可以使用”-S”更改单位，比如使用”vmstat -S m”切换为MB</p>
</li>
<li><p><a href="http://www.codebooklet.com/2021/10/29/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/#vmstat">更多关于vmstat的介绍</a></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~/FrozenZone/ProgramTest/temp<span class="comment"># vmstat 2 10</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 3  0      0 1371868 146284 399248    0    0     2     4   18    8  1  0 99  0  0</span><br><span class="line"> 2  0      0 1371860 146284 399248    0    0     0     0  483 1202  0  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     2  458 1161  1  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0    12  460 1160  1  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  454 1160  1  0 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  449 1151  0  0 100  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  446 1149  0  1 98  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  451 1160  1  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  449 1152  0  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  459 1163  1  0 99  0  0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令笔记</title>
    <url>/2021/10/29/Linux/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><strong>该笔记仅记录个人使用过的命令，以及用该命令做过什么，不是完整说明文档</strong><span id="more"></span></li>
</ul>
<hr>
<h1 id="目录-INDEX"><a href="#目录-INDEX" class="headerlink" title="目录 INDEX"></a>目录 INDEX</h1><table>
<thead>
<tr>
<th align="center">首字母</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">C</td>
<td align="center"><a href="#chown">chown</a>   <a href="#chgrp">chgrp</a></td>
</tr>
<tr>
<td align="center">D</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">E</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">F</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">G</td>
<td align="center"><a href="#groups">groups</a></td>
</tr>
<tr>
<td align="center">H</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">I</td>
<td align="center"><a href="#id">id</a></td>
</tr>
<tr>
<td align="center">J</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">K</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">L</td>
<td align="center"><a href="#ls">ls</a></td>
</tr>
<tr>
<td align="center">M</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">N</td>
<td align="center"><a href="#newgrp">newgrp</a></td>
</tr>
<tr>
<td align="center">O</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">P</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">R</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">S</td>
<td align="center"><a href="#stat">stat</a></td>
</tr>
<tr>
<td align="center">T</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">U</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">V</td>
<td align="center"><a href="#vmstat">vmstat</a></td>
</tr>
<tr>
<td align="center">W</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">X</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Y</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center"></td>
</tr>
</tbody></table>
 <div id="chgrp"><font size=20,font-weight:bold>chgrp</font></div>
- 使用“chgrp”可以**更改文件的所属用户组**

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~<span class="comment"># ls -l a</span></span><br><span class="line">-rw-r--r-- 1 root jerry 0 Nov 26 20:36 a</span><br><span class="line">root@Aioy:~<span class="comment"># chgrp root a</span></span><br><span class="line">root@Aioy:~<span class="comment"># ls -l a</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 26 20:36 a</span><br></pre></td></tr></table></figure>

 <div id="chown"><font size=20,font-weight:bold>chown</font></div>
- 使用“chown”可以**更改文件的所属用户，或者所属用户组**

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~<span class="comment"># touch a （创建一个名为a的文件）</span></span><br><span class="line">root@Aioy:~<span class="comment"># chown root:jerry a （修改所属用户为root所属用户组为jerry）</span></span><br><span class="line">root@Aioy:~<span class="comment"># ls -l a</span></span><br><span class="line">-rw-r--r-- 1 root jerry 0 Nov 26 20:36 a</span><br><span class="line"><span class="comment">#可以使用 :group 单独修改所属用户组，效果同 chgrp 命令</span></span><br></pre></td></tr></table></figure>

 <div id="newgrp"><font size=20,font-weight:bold>newgrp</font></div>
- 使用“newgrp”**切换用户的有效用户组（Effective Group），但前提是确保用户已经在将要切换的用户组内**

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~<span class="comment"># groups （该命令输出的第一个组是有效用户组）</span></span><br><span class="line">root jerry</span><br><span class="line">root@Aioy:~<span class="comment"># newgrp jerry</span></span><br><span class="line">root@Aioy:~<span class="comment"># groups</span></span><br><span class="line">jerry root</span><br></pre></td></tr></table></figure>

 <div id="groups"><font size=20,font-weight:bold>groups</font></div>
- 使用“groups”查看**查看某用户当前全部所属用户组，第一个为有效用户组（Effective Group）**

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~<span class="comment"># groups</span></span><br><span class="line">root</span><br><span class="line">root@Aioy:~<span class="comment"># groups jerry</span></span><br><span class="line">jerry : jerry</span><br></pre></td></tr></table></figure>

 <div id="id"><font size=20,font-weight:bold>id</font></div>

<ul>
<li>使用“id”命令用于<strong>显示一个真实有效的用户以及其归属用户组</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用 id 指令查看某用户信息</span></span><br><span class="line">root@Aioy:~/<span class="built_in">test</span><span class="comment"># id jerry</span></span><br><span class="line">uid=1001(jerry) gid=1001(jerry) groups=1001(jerry)</span><br><span class="line"><span class="comment">#groups属性暗示了一个用户可以归属多个组</span></span><br></pre></td></tr></table></figure>

 <div id="stat"><font size=20,font-weight:bold>stat</font></div>

<ul>
<li>使用“stat”命令用于显示文件 inode 内容，格式 stat [目录]</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~/FrozenZone/ProgramTest/temp<span class="comment"># stat dir</span></span><br><span class="line">  File: dir</span><br><span class="line">  Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fc01h/64513d    Inode: 1058114     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 15:52:49.926157173 +0800</span><br><span class="line">Modify: 2021-11-06 15:29:16.505536795 +0800</span><br><span class="line">Change: 2021-11-06 15:29:16.505536795 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>

 <div id="ls"><font size=20,font-weight:bold>ls</font></div>

<ul>
<li>使用”ls”命令用于显示<strong>指定工作目录</strong>下的内容，格式 ls [参数] [指定目录]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">常用参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示指定目录下所有文件，包括隐藏文件</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">显示指定目录下的</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">显示文件类型、权限、所有者、文件大小等详细信息</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">若指定目录下有其他子目录，则将子目录中内容也显示</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">将指定目录下的文件以“创建时间”先后顺序显示</td>
</tr>
</tbody></table>
 <div id="vmstat"><font size=20,font-weight:bold>vmstat</font></div>

<ul>
<li>使用”vmstat”命令查看主要系统性能指标 （参数①：采样频率（秒），参数②：采样次数，默认1次，如果设置了①而没有设置②则无限循环）</li>
<li>默认输出单位为KB，可以使用”-S”更改单位，比如使用”vmstat -S m”切换为MB</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~/FrozenZone/ProgramTest/temp<span class="comment"># vmstat 2 10</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 3  0      0 1371868 146284 399248    0    0     2     4   18    8  1  0 99  0  0</span><br><span class="line"> 2  0      0 1371860 146284 399248    0    0     0     0  483 1202  0  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     2  458 1161  1  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0    12  460 1160  1  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  454 1160  1  0 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  449 1151  0  0 100  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  446 1149  0  1 98  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  451 1160  1  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  449 1152  0  1 99  0  0</span><br><span class="line"> 0  0      0 1371860 146284 399248    0    0     0     0  459 1163  1  0 99  0  0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Procs</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>r</strong>: The number of runnable processes (running or waiting for run time).</td>
<td align="center">可运行的进程数（正在运行或等待CPU时间）</td>
</tr>
<tr>
<td align="left"><strong>b</strong> The number of processes in uninterruptible sleep.</td>
<td align="center">Uninterruptible Sleep进程数 <a href="https://cloud.tencent.com/developer/article/1581022">《Linux进程状态》</a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Memory</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>swpd</strong>: the amount of virtual memory used.</td>
<td align="center">虚拟内存使用大小</td>
</tr>
<tr>
<td align="left"><strong>free</strong>: the amount of idle memory.</td>
<td align="center">空闲内存大小</td>
</tr>
<tr>
<td align="left"><strong>buff</strong>: the amount of memory used as buffers.</td>
<td align="center">作为缓存区的内存</td>
</tr>
<tr>
<td align="left"><strong>cache</strong>: the amount of memory used as cache.</td>
<td align="center">作为Cache的内存</td>
</tr>
<tr>
<td align="left"><strong>inact</strong>: the amount of inactive memory.  (-a option)</td>
<td align="center">非活动内存大小  <a href="https://blog.csdn.net/weixin_39962285/article/details/116759825">《Linux kernel内存回收机制》</a></td>
</tr>
<tr>
<td align="left"><strong>active</strong>: the amount of active memory.  (-a option)</td>
<td align="center">活动内存大小 <a href="https://blog.csdn.net/weixin_39962285/article/details/116759825">《Linux kernel内存回收机制》</a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Swap</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>si</strong>: Amount of memory swapped in from disk (/s).</td>
<td align="center">每秒 交换分区=&gt;内存 的数据量</td>
</tr>
<tr>
<td align="left"><strong>so</strong>: Amount of memory swapped to disk (/s)..</td>
<td align="center">每秒 内存=&gt;交换分区 的数据量</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">IO</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>bi</strong>: Blocks received from a block device (blocks/s).</td>
<td align="center">每秒从块设备中读入的数据的总量，单位是块</td>
</tr>
<tr>
<td align="left"><strong>bo</strong>: Blocks sent to a block device (blocks/s).</td>
<td align="center">每秒写到块设备的数据的总量，单位是块</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">System</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>in</strong>: The number of interrupts per second, including the clock.</td>
<td align="center">每秒中断次数，包括<a href="https://www.cnblogs.com/yungyu16/p/12992374.html">时钟中断 </a></td>
</tr>
<tr>
<td align="left"><strong>cs</strong>: The number of context switches per second.</td>
<td align="center">每秒上下文切换的次数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">CPU</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>us</strong>: Time spent running non-kernel code.  (user time, including nice time)</td>
<td align="center">用户态代码运行的 CPU时间（%），包括nice time（低优先级程序时间）</br> <a href="https://blog.csdn.net/u010317005/article/details/80531985">《Linux进程优先级》 </a></td>
</tr>
<tr>
<td align="left"><strong>sy</strong>: Time spent running kernel code.  (system time)</td>
<td align="center">内核代码运行的 CPU 时间（%）</td>
</tr>
<tr>
<td align="left"><strong>id</strong>: Time spent idle.  Prior to Linux 2.5.41, this includes IO-wait time.</td>
<td align="center">空闲状态的 CPU 时间（%）</td>
</tr>
<tr>
<td align="left"><strong>wa</strong>: Time spent waiting for IO.  Prior to Linux 2.5.41, included in idle.</td>
<td align="center">等待IO的 CPU 时间（%）</td>
</tr>
<tr>
<td align="left"><strong>st</strong>: Time stolen from a virtual machine.  Prior to Linux 2.6.11, unknown.</td>
<td align="center">被虚拟机所盗用的 CPU 时间（%）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户身份切换</title>
    <url>/2021/11/23/Linux/Linux%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<ul>
<li>《鸟哥的Linux私房菜》第13章有关用户身份切换的相关知识的学习</li>
</ul>
<span id="more"></span>

<h1 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h1><h2 id="为什么需要身份切换"><a href="#为什么需要身份切换" class="headerlink" title="为什么需要身份切换"></a>为什么需要身份切换</h2><ul>
<li><strong>安全</strong>：日常操作使用普通账号避免不必要的误操，启动系统服务时希望用较低的权限，比如使用apache这样一个用户来启动Apache服务，这样即使服务被攻击也不会造成系统损坏</li>
<li><strong>软件限制</strong>：远古时代，一些telnel程序默认不允许使用root身份登录<blockquote>
<blockquote>
<p>一般情况下使用普通账户登录系统，等有需要进行系统维护或者软件更新时才转变为root身份</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="如何切换至root身份"><a href="#如何切换至root身份" class="headerlink" title="如何切换至root身份"></a>如何切换至root身份</h2><h3 id="①-su"><a href="#①-su" class="headerlink" title="① su"></a>① su</h3><ul>
<li>是<strong>最简单的身份切换命令，可以进行任何身份的切换</strong></li>
<li><strong>使用方法：su [-lm] [-c command] [username]  （如果没有指定username则默认root）</strong><br>可选参数|说明</li>
<li>–|—</li>
<li>|单纯使用 “su -” 代表使用 login shell 的变量文件读取方式来登录（即环境变量是切换后的用户的，与 -m 区分）</li>
<li>l|与 - 类似，但是后面必须显式写明username，也是 login-shell 的方式</li>
<li>m|与 -p 一样，表示使用目前的环境，不读取切换后使用者的配置文件（会导致切换后身份所特有的命令需要使用绝对路径执行）</li>
<li>c|仅进行一次命令，执行命令写在后面即可</li>
</ul>
<p>-<strong>有没有减号 - 直接决定了是使用 login shell 还是 non-login shell 的变量读取方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一个简单的&quot;su&quot;和&quot;su -&quot;对比演示</span></span><br><span class="line">git@Aioy:~$ su</span><br><span class="line">Password:</span><br><span class="line">root@Aioy:/home/git<span class="comment"># env | grep &#x27;git&#x27;</span></span><br><span class="line">PWD=/home/git</span><br><span class="line">LOGNAME=git</span><br><span class="line">USER=git</span><br><span class="line">-----------------------------------------</span><br><span class="line">git@Aioy:~$ su -</span><br><span class="line">Password:</span><br><span class="line">root@Aioy:/home/git<span class="comment"># env | grep &#x27;git&#x27;</span></span><br><span class="line">（没有任何输出）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用non-login shell方式（即不加减号参数）可能会导致身份切换后依旧接收到旧身份的信息，或者需要使用绝对路径来使用切换后用户的特殊命令等情况，总之就是可能造成很多麻烦</strong></li>
</ul>
<h3 id="②-sudo"><a href="#②-sudo" class="headerlink" title="② sudo"></a>② sudo</h3><ul>
<li><strong>系统初始默认只有root可以执行sudo</strong></li>
<li><strong>sudo可以让你以其他用户的身份执行命令，通常是root身份</strong></li>
<li><strong>一般用户如果想要拥有使用sudo的权限，需要和管理员事先联系审核，成为信任用户</strong></li>
<li><strong>与su不同的是，使用sudo不需要切换对象的密码，而是自己的密码，甚至不需要密码</strong></li>
</ul>
<h3 id="sudo的执行流程"><a href="#sudo的执行流程" class="headerlink" title="sudo的执行流程"></a>sudo的执行流程</h3><ol>
<li>当用户执行sudo时，操作系统在 /etc/sudoers 文件中查找用户是否具有执行sudo的权限</li>
<li>如果可以执行sudo，则需要用户输入自己的密码（root执行sudo不需要密码）</li>
<li>密码正确则开始执行sudo后的command</li>
</ol>
<ul>
<li><strong>执行sudo的重点：/etc/sudoers 文件中是否有权限，如果没有则需要root使用visudo修改该文件，或者直接修改该文件（修改方法可以在其他文章中学习）</strong></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统运行级别</title>
    <url>/2021/12/01/Linux/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li>Linux系统一般有7个运行级别（runlevel）从level 0 ~ 6，可能有更多等级，操作系统根据当前正在运行的功能级别，具有不同的功能</li>
<li><a href="https://blog.csdn.net/qq_21453783/article/details/100251461">参考文章</a></li>
</ul>
<span id="more"></span>

<h2 id="Linux一般的7个运行等级"><a href="#Linux一般的7个运行等级" class="headerlink" title="Linux一般的7个运行等级"></a>Linux一般的7个运行等级</h2><table>
<thead>
<tr>
<th>运行等级</th>
<th>模式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>系统关机模式</td>
<td>系统默认运行级别不能设置为0，否则无法正常启动系统</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式</td>
<td>也称为救援模式，root权限，用于系统维护，禁止远程登陆，类似Windows下的安全模式登录</td>
</tr>
<tr>
<td>2</td>
<td>多用户模式</td>
<td>多用户，但是没有网络文件（NFS）支持</td>
</tr>
<tr>
<td>3</td>
<td>完整的多用户文本模式</td>
<td>多用户，有网络文件系统，用户登录后进入控制台命令行模式，在没有网络的环境下等同于运行级别2</td>
</tr>
<tr>
<td>4</td>
<td>预留功能</td>
<td>一般不用，在一些特殊情况下可以用来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置</td>
</tr>
<tr>
<td>5</td>
<td>图形化模式</td>
<td>登陆后进入图形GUI模式或GNOME、KDE图形化界面，如X Window系统</td>
</tr>
<tr>
<td>6</td>
<td>重启模式</td>
<td>默认运行级别不能设为6，否则无法正常启动系统</td>
</tr>
</tbody></table>
<h2 id="如何查看当前运行等级"><a href="#如何查看当前运行等级" class="headerlink" title="如何查看当前运行等级"></a>如何查看当前运行等级</h2><h3 id="使用-runlevel-查看当前运行等级"><a href="#使用-runlevel-查看当前运行等级" class="headerlink" title="使用 runlevel 查看当前运行等级"></a>使用 runlevel 查看当前运行等级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[raven-1@localhost rc.d]$ runlevel</span><br><span class="line">N 5 <span class="comment">#图形化模式</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-systemctl-get-default-查看默认启动方式"><a href="#使用-systemctl-get-default-查看默认启动方式" class="headerlink" title="使用 systemctl get-default 查看默认启动方式"></a>使用 systemctl get-default 查看默认启动方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[raven-1@localhost rc.d]$ systemctl get-default </span><br><span class="line">graphical.target <span class="comment">#图形化启动</span></span><br></pre></td></tr></table></figure>

<h2 id="切换运行等级"><a href="#切换运行等级" class="headerlink" title="切换运行等级"></a>切换运行等级</h2><ul>
<li>使用 init 3 切换到“完整的多用户文本模式”<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[raven-1@localhost rc.d]$ init 3</span><br><span class="line"><span class="comment"># 接下来需要输入管理员密码</span></span><br></pre></td></tr></table></figure></li>
<li>之后可以使用 init 5 再次切换回“图形化模式”，需要重新登录认证</li>
</ul>
<h2 id="运行级别配置文件"><a href="#运行级别配置文件" class="headerlink" title="运行级别配置文件"></a>运行级别配置文件</h2><ul>
<li>在**/etc/rc.d/**目录下有以下文件，分别对应运行等级<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[raven-1@localhost ~]$ <span class="built_in">cd</span> /etc/rc.d</span><br><span class="line">[raven-1@localhost rc.d]$ ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x. 2 root root  70 Oct 22 01:42 init.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:42 rc0.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:42 rc1.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:42 rc2.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:42 rc3.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:42 rc4.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:49 rc5.d</span><br><span class="line">drwxr-xr-x. 2 root root  45 Oct 22 01:42 rc6.d</span><br><span class="line">-rw-r--r--. 1 root root 473 Mar 31  2020 rc.local</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux硬链接软连接和复制的区别</title>
    <url>/2021/11/06/Linux/Linux%E7%A1%AC%E9%93%BE%E6%8E%A5%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>通过Ubuntu Linux实机演示 硬链接Hard Link, 软连接Symbolic Link, 复制Copy之间的区别</strong></p>
<span id="more"></span>

<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="①-硬连接-Hard-Link"><a href="#①-硬连接-Hard-Link" class="headerlink" title="① 硬连接 Hard Link"></a>① 硬连接 Hard Link</h2><h3 id="如何建立硬连接？"><a href="#如何建立硬连接？" class="headerlink" title="如何建立硬连接？"></a>如何建立硬连接？</h3><ul>
<li>使用“ln file file_link”即可为file创建一个名为file_link的硬连接</li>
</ul>
<h3 id="硬连接的特点"><a href="#硬连接的特点" class="headerlink" title="硬连接的特点"></a>硬连接的特点</h3><ul>
<li>硬连接通过<strong>索引节点（inode）</strong>进行连接，链接同一文件的硬连接有相同的inode</li>
<li>通过硬连接，可以有多个不同连接访问到同一个文件</li>
<li><strong>硬连接本身也是普通文件（regular file）</strong>，因此<strong>目录文件无法创建硬连接</strong></li>
<li>只删除部分硬连接不影响文件本身，只有当<strong>所有硬连接都删除后，文件才会真正被释放</strong></li>
<li>每个硬连接<strong>会让文件的Links数增加（+1）</strong>（使用stat查看）</li>
</ul>
<h2 id="②-软连接-Symbolic-Link"><a href="#②-软连接-Symbolic-Link" class="headerlink" title="② 软连接 Symbolic Link"></a>② 软连接 Symbolic Link</h2><h3 id="如何创建软连接？"><a href="#如何创建软连接？" class="headerlink" title="如何创建软连接？"></a>如何创建软连接？</h3><ul>
<li>使用“ln -s”建立软连接，也叫符号链接（Symbolic Link）</li>
</ul>
<h3 id="软连接的特点"><a href="#软连接的特点" class="headerlink" title="软连接的特点"></a>软连接的特点</h3><ul>
<li>类似于Windows的快捷方式，<strong>软连接与被链接文件有不同inode</strong>，因此删除软连接不会影响文件</li>
<li>实际上，<strong>符号链接的文件是一个特殊的文本文件</strong>，包含着链接另一端的位置信息</li>
<li>软连接<strong>不会增加文件的Links</strong>（使用stat查看）</li>
</ul>
<h2 id="③-复制-Copy"><a href="#③-复制-Copy" class="headerlink" title="③ 复制 Copy"></a>③ 复制 Copy</h2><h3 id="如何复制文件？"><a href="#如何复制文件？" class="headerlink" title="如何复制文件？"></a>如何复制文件？</h3><ul>
<li>使用“cp file file_copy”即可复制file文件为file_copy</li>
</ul>
<h3 id="复制的特点"><a href="#复制的特点" class="headerlink" title="复制的特点"></a>复制的特点</h3><ul>
<li>复制文件，操作系统会为复制品创建新的inode，也就是相当于一个新的文件</li>
</ul>
<hr>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="①-创建一个net文件为其添加硬连接并复制"><a href="#①-创建一个net文件为其添加硬连接并复制" class="headerlink" title="① 创建一个net文件为其添加硬连接并复制"></a>① 创建一个net文件为其添加硬连接并复制</h2><h3 id="使用stat-net查看net文件"><a href="#使用stat-net查看net文件" class="headerlink" title="使用stat net查看net文件"></a>使用stat net查看net文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File: net</span><br><span class="line">  Size: 8               Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fc01h/64513d    Inode: 1058116     Links: 2</span><br><span class="line">Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 16:31:22.620947582 +0800</span><br><span class="line">Modify: 2021-11-06 15:48:59.433492576 +0800</span><br><span class="line">Change: 2021-11-06 16:18:36.537452640 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<h3 id="使用stat-link-net查看net的硬连接"><a href="#使用stat-link-net查看net的硬连接" class="headerlink" title="使用stat link_net查看net的硬连接"></a>使用stat link_net查看net的硬连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File: link_net</span><br><span class="line">  Size: 8               Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fc01h/64513d    Inode: 1058116     Links: 2</span><br><span class="line">Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 16:31:22.620947582 +0800</span><br><span class="line">Modify: 2021-11-06 15:48:59.433492576 +0800</span><br><span class="line">Change: 2021-11-06 16:18:36.537452640 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<h3 id="使用stat-copy-net查看net的复制"><a href="#使用stat-copy-net查看net的复制" class="headerlink" title="使用stat copy_net查看net的复制"></a>使用stat copy_net查看net的复制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File: copy_net</span><br><span class="line">  Size: 8               Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fc01h/64513d    Inode: 1058123     Links: 1</span><br><span class="line">Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 16:31:22.620947582 +0800</span><br><span class="line">Modify: 2021-11-06 16:31:22.620947582 +0800</span><br><span class="line">Change: 2021-11-06 16:31:22.620947582 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>

<h2 id="②-创建一个dir文件为其添加软连接并复制"><a href="#②-创建一个dir文件为其添加软连接并复制" class="headerlink" title="② 创建一个dir文件为其添加软连接并复制"></a>② 创建一个dir文件为其添加软连接并复制</h2><h3 id="使用stat-dir查看dir文件"><a href="#使用stat-dir查看dir文件" class="headerlink" title="使用stat dir查看dir文件"></a>使用stat dir查看dir文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File: dir</span><br><span class="line">  Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fc01h/64513d    Inode: 1058114     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 15:52:49.926157173 +0800</span><br><span class="line">Modify: 2021-11-06 15:29:16.505536795 +0800</span><br><span class="line">Change: 2021-11-06 15:29:16.505536795 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<h3 id="使用stat-link-dir查看dir的软连接"><a href="#使用stat-link-dir查看dir的软连接" class="headerlink" title="使用stat link_dir查看dir的软连接"></a>使用stat link_dir查看dir的软连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File: link_dir -&gt; dir</span><br><span class="line">  Size: 3               Blocks: 0          IO Block: 4096   symbolic link</span><br><span class="line">Device: fc01h/64513d    Inode: 1058121     Links: 1</span><br><span class="line">Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 15:29:26.737743781 +0800</span><br><span class="line">Modify: 2021-11-06 15:29:25.713723071 +0800</span><br><span class="line">Change: 2021-11-06 15:29:25.713723071 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<h3 id="使用stat-copy-dir查看dir的复制"><a href="#使用stat-copy-dir查看dir的复制" class="headerlink" title="使用stat copy_dir查看dir的复制"></a>使用stat copy_dir查看dir的复制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File: copy_dir</span><br><span class="line">  Size: 0               Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fc01h/64513d    Inode: 1058122     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-11-06 16:31:04.068572412 +0800</span><br><span class="line">Modify: 2021-11-06 16:45:11.621713073 +0800</span><br><span class="line">Change: 2021-11-06 16:45:11.621713073 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<h2 id="③-分别对连接文件和复制文件进行权限操作观察原文件变化"><a href="#③-分别对连接文件和复制文件进行权限操作观察原文件变化" class="headerlink" title="③ 分别对连接文件和复制文件进行权限操作观察原文件变化"></a>③ 分别对连接文件和复制文件进行权限操作观察原文件变化</h2><h3 id="赋予执行权限前（使用“ls-li”命令查看）"><a href="#赋予执行权限前（使用“ls-li”命令查看）" class="headerlink" title="赋予执行权限前（使用“ls -li”命令查看）"></a>赋予执行权限前（使用“ls -li”命令查看）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1058122 -rw-r--r-- 1 root root 0 Nov  6 16:45 copy_dir</span><br><span class="line">1058123 -rw-r--r-- 1 root root 8 Nov  6 16:31 copy_net</span><br><span class="line">1058114 -rw-r--r-- 1 root root 0 Nov  6 15:29 dir</span><br><span class="line">1058121 lrwxrwxrwx 1 root root 3 Nov  6 15:29 link_dir -&gt; dir</span><br><span class="line">1058116 -rw-r--r-- 2 root root 8 Nov  6 15:48 link_net</span><br><span class="line">1058116 -rw-r--r-- 2 root root 8 Nov  6 15:48 net</span><br></pre></td></tr></table></figure>
<h3 id="对硬连接文件link-net-使用“chmod-x-link-net”"><a href="#对硬连接文件link-net-使用“chmod-x-link-net”" class="headerlink" title="对硬连接文件link_net 使用“chmod +x link_net”"></a>对硬连接文件link_net 使用“chmod +x link_net”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1058116 -rwxr-xr-x 2 root root 8 Nov  6 15:48 net</span><br><span class="line">1058116 -rwxr-xr-x 2 root root 8 Nov  6 15:48 link_net</span><br><span class="line">1058123 -rw-r--r-- 1 root root 8 Nov  6 16:31 copy_net</span><br></pre></td></tr></table></figure>
<ul>
<li>发现硬连接文件和文件本身权限都发生了变化</li>
</ul>
<h3 id="对软连接文件link-dir-使用“chmod-x-link-dir”"><a href="#对软连接文件link-dir-使用“chmod-x-link-dir”" class="headerlink" title="对软连接文件link_dir 使用“chmod +x link_dir”"></a>对软连接文件link_dir 使用“chmod +x link_dir”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1058114 -rwxr-xr-x 1 root root 0 Nov  6 15:29 dir</span><br><span class="line">1058121 lrwxrwxrwx 1 root root 3 Nov  6 15:29 link_dir -&gt; dir</span><br><span class="line">1058122 -rw-r--r-- 1 root root 0 Nov  6 16:45 copy_dir</span><br></pre></td></tr></table></figure>
<h3 id="进一步对软连接测试-使用“chmod-x-link-dir”"><a href="#进一步对软连接测试-使用“chmod-x-link-dir”" class="headerlink" title="进一步对软连接测试 使用“chmod -x link_dir”"></a>进一步对软连接测试 使用“chmod -x link_dir”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1058114 -rw-r--r-- 1 root root 0 Nov  6 15:29 dir</span><br><span class="line">1058121 lrwxrwxrwx 1 root root 3 Nov  6 15:29 link_dir -&gt; dir</span><br><span class="line">1058122 -rw-r--r-- 1 root root 0 Nov  6 16:45 copy_dir</span><br></pre></td></tr></table></figure>
<ul>
<li>发现link_dir没变，说明通过修改软连接文件，不会对软连接产生影响，而是间接修改原文件</li>
</ul>
<h2 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h2><ul>
<li>除了软连接的文件类型是Symbolic file，其他无论文件本身、硬链接还是复制都是regular file</li>
<li>硬链接与文件本身 inode 完全相同，软连接和复制会赋予新的 inode</li>
<li>对链接操作会影响原文件，对复制文件的操作不会影响原文件</li>
<li>对软连接操作不会影响软链接，而是间接作用于原文件</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux账号管理</title>
    <url>/2021/11/19/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>《鸟哥的Linux私房菜》第13章有关用户管理的相关知识的学习</li>
</ul>
<span id="more"></span>

<h1 id="Linux的账号"><a href="#Linux的账号" class="headerlink" title="Linux的账号"></a>Linux的账号</h1><h2 id="用户标识符：UID-amp-GID"><a href="#用户标识符：UID-amp-GID" class="headerlink" title="用户标识符：UID &amp; GID"></a>用户标识符：UID &amp; GID</h2><ul>
<li>每一个登录系统的用户都会至少获得2个ID，即UID（User ID）与GID（Group ID）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用 id 指令查看某用户信息</span></span><br><span class="line">root@Aioy:~/<span class="built_in">test</span><span class="comment"># id jerry</span></span><br><span class="line">uid=1001(jerry) gid=1001(jerry) groups=1001(jerry)</span><br><span class="line"><span class="comment">#groups属性暗示了一个用户可以归属多个组</span></span><br></pre></td></tr></table></figure>



<h2 id="UID的范围和用户特性"><a href="#UID的范围和用户特性" class="headerlink" title="UID的范围和用户特性"></a>UID的范围和用户特性</h2><table>
<thead>
<tr>
<th>ID范围</th>
<th>用户特性</th>
</tr>
</thead>
<tbody><tr>
<td>系统管理员：0</td>
<td>一般只有root一个用户，也可以通过修改其他用户权限为0增加系统管理员，不过可能会造成混淆</td>
</tr>
<tr>
<td>系统账号：1~999（通常不可登录）</td>
<td><strong>保留给操作系统使用的ID，1<del>200由Linux发行版自行建立的系统账号，201</del>999若用户有系统账号需求时可以使用，比如启动网络服务时候如果不希望用root权限，则可以使用系统账号</strong></td>
</tr>
<tr>
<td>普通账号：1000~2^32-1（&gt;= Kernel3.10.X）</td>
<td>给一般用户使用，实际范围上限可能更小也可能更大</td>
</tr>
</tbody></table>
<h2 id="passwd文件-amp-shadow文件"><a href="#passwd文件-amp-shadow文件" class="headerlink" title="passwd文件 &amp; shadow文件"></a>passwd文件 &amp; shadow文件</h2><h3 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h3><ul>
<li>在Linux Ubuntu下用户账号信息存放在**/etc/password**</li>
<li>每一行都代表一个账号，<strong>系统账号是操作系统正常运行所必须的，比如daemon、bin等</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#passwd文件的部分展示，其中 : 作为分隔符，一共有7个</span></span><br><span class="line"><span class="comment">#用户名:密码:UID:GID:用户信息说明栏:家目录:默认shell</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="为什么-密码-字段为-x"><a href="#为什么-密码-字段为-x" class="headerlink" title="为什么 密码 字段为 x"></a>为什么 密码 字段为 x</h4><ul>
<li> <strong>早期linux将密码也放在 /etc/passwd 中，不过由于所有程序都能读取该文件所以容易造成密码泄露问题，因此密码字段被移动到 /etc/shadow 中</strong></li>
</ul>
<h3 id="shadow文件"><a href="#shadow文件" class="headerlink" title="shadow文件"></a>shadow文件</h3><ul>
<li>在Linux Ubuntu下用户账号的密码存放在**/etc/shadow**</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#shadow文件的部分展示，其中 : 作为分隔符，一共有9个</span></span><br><span class="line">man:*:18375:0:99999:7:::</span><br><span class="line">lp:*:18375:0:99999:7:::</span><br><span class="line">mail:*:18375:0:99999:7:::</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1.用户名</td>
<td>用户名，需要与/etc/passwd对应</td>
</tr>
<tr>
<td>2.密码</td>
<td>经过摘要运算（比如MD5，SHA）后的密码，很难（单向性）但可能被破译，<strong>系统账号密码为星号</strong>*</td>
</tr>
<tr>
<td>3.最近修改密码的日期</td>
<td>自Linux日期（1970年1月1日）开始后的天数</td>
</tr>
<tr>
<td>4.密码不可被修改的天数</td>
<td>自[最近修改密码的日期]开始，需要过几天才可以修改密码，如果是0则可以立即修改</td>
</tr>
<tr>
<td>5.密码需要重新修改的天数</td>
<td>自[最近修改密码的日期]开始，强制用户在此字段规定天数内修改密码，否则该账号密码过期（失效前可用）</td>
</tr>
<tr>
<td>6.密码需要修改期限前的警告天数</td>
<td>相对[密码需要重新修改的天数]还剩此字段规定天数时，系统会提醒该用户重新设置密码</td>
</tr>
<tr>
<td>7.密码失效日（不同于密码过期日）</td>
<td>在[密码需要重新修改的天数]过后，如果用户还是没有修改密码，则该账号无法使用此密码登录</td>
</tr>
<tr>
<td>8.账号失效日</td>
<td>账号自Linux日期（1970年1月1日）开始后的天数内有效，超过则失效，常用于付费服务</td>
</tr>
<tr>
<td>9.保留字段</td>
<td>为之后的新功能预留</td>
</tr>
</tbody></table>
<h3 id="权限比较"><a href="#权限比较" class="headerlink" title="权限比较"></a>权限比较</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:/etc<span class="comment"># ls -l /etc/passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 1737 Oct 23 10:29 /etc/passwd</span><br><span class="line">root@Aioy:/etc<span class="comment"># ls -l /etc/shadow</span></span><br><span class="line">-rw-r----- 1 root shadow 1235 Oct 23 10:34 /etc/shadow</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出来passwd文件由于对其他用户开放了 r 读权限，因此早期存放密码的设计确实不安全</li>
</ul>
<h2 id="用户登陆过程"><a href="#用户登陆过程" class="headerlink" title="用户登陆过程"></a>用户登陆过程</h2><ol>
<li>用户本地终端或使用ssh远程发起登陆请求，输入账号和密码</li>
<li>账号核对：在 /etc/passwd 中查找是否有用户输入的账号</li>
<li>密码核对：在 /etc/shadow 找出对应的账号与UID然后核对密码</li>
<li>登陆成功，进入Shell管理阶段</li>
</ol>
<h1 id="Linux的用户组"><a href="#Linux的用户组" class="headerlink" title="Linux的用户组"></a>Linux的用户组</h1><h2 id="group文件-amp-gshadow文件"><a href="#group文件-amp-gshadow文件" class="headerlink" title="group文件 &amp; gshadow文件"></a>group文件 &amp; gshadow文件</h2><h3 id="group文件"><a href="#group文件" class="headerlink" title="group文件"></a>group文件</h3><ul>
<li>在Linux Ubuntu下用户账号信息存放在**/etc/group**</li>
<li>每一行都代表一个用户组<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#group文件文件的部分展示，其中 : 作为分隔符，一共有4个</span></span><br><span class="line"><span class="comment">#组名:用户组密码:GID:此用户组支持的账号名称</span></span><br><span class="line">root:x:0:</span><br><span class="line">daemon:x:1:</span><br><span class="line">bin:x:2:</span><br><span class="line">sys:x:3:</span><br><span class="line">adm:x:4:syslog</span><br><span class="line">tty:x:5:syslog</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>：新版Linux中，<strong>初始用户组的用户群</strong>已经不会加入第四个字段，比如root的主要用户组为root，那么不会在group文件第四个字段看到root出现（相当于隐式声明）</li>
</ul>
<h3 id="gshadow文件"><a href="#gshadow文件" class="headerlink" title="gshadow文件"></a>gshadow文件</h3><ul>
<li>在Linux Ubuntu下用户账号信息存放在**/etc/gshadow**</li>
<li>每一行都代表一个用户组<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gshadow文件文件的部分展示，其中 : 作为分隔符，一共有4个</span></span><br><span class="line"><span class="comment">#组名:用户组密码:组管理员（在etc/gpasswd中）:此用户组支持的账号名称（多个用户间用逗号,分隔）</span></span><br><span class="line">root:*::</span><br><span class="line">daemon:*::</span><br><span class="line">bin:*::</span><br><span class="line">sys:*::</span><br><span class="line">adm:*::syslog</span><br><span class="line">tty:*::syslog</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="有效用户组-amp-初始用户组"><a href="#有效用户组-amp-初始用户组" class="headerlink" title="有效用户组 &amp; 初始用户组"></a>有效用户组 &amp; 初始用户组</h2><blockquote>
<blockquote>
<blockquote>
<p>假如一个用户同时加入多个用户组，那么在执行任务过程中，究极以哪个用户组为准呢？——有效用户组（Effective Group）</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="有效用户组（Effective-Group）"><a href="#有效用户组（Effective-Group）" class="headerlink" title="有效用户组（Effective Group）"></a>有效用户组（Effective Group）</h3><ul>
<li><p>在 /etc/passwd 中的第四字段 GID 即所谓的有效用户组，<strong>用户登录后会立即拥有初始用户组的相关权限</strong></p>
</li>
<li><p><strong>groups 命令</strong>：查看某用户当前全部所属用户组，<strong>第一个为有效用户组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~<span class="comment"># groups</span></span><br><span class="line">root</span><br><span class="line">root@Aioy:~<span class="comment"># groups jerry</span></span><br><span class="line">jerry : jerry</span><br><span class="line"><span class="comment">#注意只有第一个输出是有效用户组</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>newgrp 命令</strong>：切换有效用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Aioy:~<span class="comment"># newgrp jerry</span></span><br><span class="line">root@Aioy:~<span class="comment"># groups</span></span><br><span class="line">jerry root</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="有效用户组的作用"><a href="#有效用户组的作用" class="headerlink" title="有效用户组的作用"></a>有效用户组的作用</h3><ul>
<li><strong>通常，有效用户组的作用是新建文件</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于root当前有效用户组是root，因此文件所属用户组就是root</span></span><br><span class="line">root@Aioy:~<span class="comment"># touch hello</span></span><br><span class="line">root@Aioy:~<span class="comment"># ls -l hello</span></span><br><span class="line">-rw-r--r-- 1 root root    0 Nov 26 18:17 hello</span><br><span class="line">root@Aioy:~<span class="comment"># newgrp jerry （切换有效用户组至jerry）</span></span><br><span class="line">root@Aioy:~<span class="comment"># touch world</span></span><br><span class="line">root@Aioy:~<span class="comment"># ls -l world</span></span><br><span class="line">-rw-r--r-- 1 root jerry 0 Nov 26 18:20 world</span><br></pre></td></tr></table></figure>

<h3 id="初始用户组（Initial-Group）"><a href="#初始用户组（Initial-Group）" class="headerlink" title="初始用户组（Initial Group）"></a>初始用户组（Initial Group）</h3><ul>
<li><strong>在 /etc/passwd 文件中，每行用户的GID就是初始用户组（Initial Group）</strong>，用户登录后就会获取</li>
<li>**对于非初始用户组，则需要在 /etc/group 中找到需要加入的组名，将用户名写入第四栏中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例：将jerry加入root用户组</span></span><br><span class="line">root@Aioy:~<span class="comment"># vim /etc/group</span></span><br><span class="line">root:x:0:jerry</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程</title>
    <url>/2021/11/10/Python/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>还在不断更新中，主要内容为使用Python基于UDP、TCP进行网络编程，本学期结束之后会将相关的课程项目通过GitHub分享</strong></p>
<span id="more"></span>

<h1 id="Chapter1-Client-Server网络编程基础"><a href="#Chapter1-Client-Server网络编程基础" class="headerlink" title="Chapter1. Client / Server网络编程基础"></a>Chapter1. Client / Server网络编程基础</h1><h2 id="协议栈与库"><a href="#协议栈与库" class="headerlink" title="协议栈与库"></a>协议栈与库</h2><ul>
<li><strong>协议栈（Protocol Stack）</strong>：<strong>一系列基础的网络服务集合</strong>，是复杂网络服务的基石</li>
<li><strong>库（Library）</strong>：分为<strong>标准库</strong>与<strong>第三方库</strong>，<strong>能使用库的情况绝不要造轮子</strong></li>
</ul>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><ul>
<li><p>Python3对<strong>字符（character）</strong>与<strong>底层字节序列（byte）</strong>做了明确区分，对使用者可见的只有字符，但实际上底层的表示方法可能是不同的，因此需要注意<strong>编码（encoding）</strong>与<strong>解码（decoding）</strong></p>
</li>
<li><p>传输层（Transport Layer）使用字节传输，因此<strong>socket编程需要先编码为字节（Byte）</strong></p>
</li>
<li><p><strong>Python3永远不会自动将字节（byte）转换为字符（character）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#区分字节（byte）与字符（character）</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#将字节（byte）转换为字符（character）</span></span><br><span class="line">    input_bytes = <span class="string">b&#x27;\xff\xfe4\x001\x003\x00 \x00i\x00s\x00 \x00i\x00n\x00.\x00&#x27;</span> <span class="comment">#使用前缀&#x27;b&#x27;表示后续是字节（byte）表示</span></span><br><span class="line">    input_characters = input_bytes.decode(<span class="string">&quot;UTF-16&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(input_characters))</span><br><span class="line">    <span class="comment">#将字符（character）转换为字节（byte）</span></span><br><span class="line">    output_characters = <span class="string">&quot;We are friends&quot;</span></span><br><span class="line">    output_bytes = output_characters.encode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(output_bytes))</span><br></pre></td></tr></table></figure></li>
<li><p>使用 repr() 将返回对象规范的字符串表示（Return the canonical string representation of the object.），这里使用是为了对比</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">&#x27;413 is in.&#x27;</span>    </span><br><span class="line">b<span class="string">&#x27;We are friends&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**字符（character）有前缀字母’b’**，也就是byte</li>
<li><strong>字节（byte）有前缀字母’b’</strong></li>
</ul>
<h2 id="端口号（Port）"><a href="#端口号（Port）" class="headerlink" title="端口号（Port）"></a>端口号（Port）</h2><table>
<thead>
<tr>
<th>端口分类</th>
<th>端口号范围</th>
<th>使用场合</th>
</tr>
</thead>
<tbody><tr>
<td>知名端口（Well-known Port）</td>
<td>0~1023</td>
<td>分配给最重要、最常用的服务，主要用于操作系统，<strong>需要管理员权限才能执行</strong></td>
</tr>
<tr>
<td>注册端口（Registered Ports）</td>
<td>1024~49151</td>
<td>任何用户都可以使用，IANA（互联网数字分配机构）建议只在使用指定服务时使用注册端口</td>
</tr>
<tr>
<td>动态和或私有端口（Dynamic/ Private Ports）</td>
<td>49151~65535</td>
<td>随意使用，<strong>Client未指定端口时，现代操作系统一般会从这些端口中随机选择端口用于服务</strong></td>
</tr>
</tbody></table>
<h2 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h2><ul>
<li>Python标准库对兼容POSIX的操作系统（Linux、Mac、Windows .etc）的网络操作的底层系统调用进行了封装，<strong>封装后的Python函数与原始系统调用名称相同</strong>（因此学会Python网络编程后再使用其他语言网络编程时会减少许多学习成本）</li>
<li>套接字（Socket）是<strong>应用层（Application Layer）与传输层（Transport Layer）之间的接口</strong>，相当于帮程序员封装了传输层以下的实现细节</li>
<li><strong>在POSIX系统中，套接字的标识fileno本质上是一个文件描述符（file descriptor）</strong></li>
</ul>
<h2 id="我的符号系统说明"><a href="#我的符号系统说明" class="headerlink" title="我的符号系统说明"></a>我的符号系统说明</h2><ul>
<li>使用<strong>（Client，Server）和（Sender，Receiver）</strong>来代替参考书中单一的客户端、服务端描述，便于区分一些概念（比如混杂）</li>
</ul>
<ol>
<li>从性质上分类：（Client，Server），谁主动提供网络服务谁就是Server，反之则是Client</li>
<li>从动作上分类：（Sender，Receiver），谁主动发信谁就是Sender，反之则是Receiver</li>
</ol>
<h1 id="Chapter2-UDP（User-Datagram-Protocol）"><a href="#Chapter2-UDP（User-Datagram-Protocol）" class="headerlink" title="Chapter2. UDP（User Datagram Protocol）"></a>Chapter2. UDP（User Datagram Protocol）</h1><ul>
<li><strong>UDP是无连接协议（connectionless）</strong>，因此<strong>UDP使用（IP，Port）二元组标识通信方</strong></li>
<li>一般不太可能在应用程序中使用UDP，如果认为UDP适用于某个场合，可以先去Chapter8了解一下<strong>消息队列</strong></li>
<li><strong>数据报（Datagram） ≠ 数据包（Packet）</strong>，后者用于网络层分组传输</li>
</ul>
<h2 id="一个最简单的UDP-C-S程序"><a href="#一个最简单的UDP-C-S程序" class="headerlink" title="一个最简单的UDP C/S程序"></a>一个最简单的UDP C/S程序</h2><ul>
<li>UDP并没有像TCP一样有明确的C/S（Client/Server）模型</li>
</ul>
<h4 id="服务端（Server）"><a href="#服务端（Server）" class="headerlink" title="服务端（Server）"></a>服务端（Server）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Server（先有Server才能有Client）</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span></span><br><span class="line"><span class="comment">#一个最简单的UDP Server</span></span><br><span class="line">    server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">    server.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">5122</span>))<span class="comment">#绑定在(IP,Port)组成的端口</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#UDP每一个recvfrom对应一个sendto</span></span><br><span class="line">        datagram,sender=server.recvfrom(<span class="number">65535</span>)<span class="comment">#接受65535Bytes的Datagram（这也是一个UDP数据报最大长度）</span></span><br><span class="line">        mes = datagram.decode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None) 创建一个空套接字，创建失败时返回值为 -1</li>
</ul>
<table>
<thead>
<tr>
<th>socket()参数说明</th>
<th>常用可选项与解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>family</strong>：套接字要使用的协议簇</td>
<td>① AF_INET (default)：IPv4<br/>② AF_INET6：IPv6<br/>③ AF_UNIX：本机通信</td>
</tr>
<tr>
<td><strong>type</strong>：套接字类型</td>
<td>① SOCK_STREAM (default)：TCP，字节流方式<br/>② SOCK_DGRAM：UDP ，数据报方式<br/>③ SOCK_RAW，原始方式</td>
</tr>
<tr>
<td><strong>fileno</strong>：通常为0（不同于None）</td>
<td>当family为AF_CAN时，可能为CAN_RAW, CAN_BCM or CAN_ISOTP</td>
</tr>
</tbody></table>
<ul>
<li>使用bind()将Socket与特定address（IP，Port）绑定在一起</li>
</ul>
<table>
<thead>
<tr>
<th>IP常用选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空字符串：（“”）</td>
<td>表示接受任何网络接口的数据包（packet）</td>
</tr>
<tr>
<td>本机：（“127.0.0.1”）或（“0.0.0.0”）[linux]</td>
<td>表示服务建立在本机，使用自环回路，通常可以用localhost访问</td>
</tr>
<tr>
<td>指定接口IP：（“比如以太网卡或无线网卡”）</td>
<td>表示可以只通过该公网IP访问</td>
</tr>
</tbody></table>
<ul>
<li><strong>服务端（Server）必须为Socket用bind()指定一个特定的接收端口</strong></li>
<li>一个<strong>UDP最大数据报长度为65535（64KB）[16bits]，而一般情况下，以太网卡或无线网卡只能处理1500B左右的数据包（packet）</strong>[UDP分组问题]</li>
<li><strong>端口号≥1024，否则需要系统管理员权限</strong></li>
</ul>
<h4 id="客户端（Client）"><a href="#客户端（Client）" class="headerlink" title="客户端（Client）"></a>客户端（Client）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Client（由Server提供（IP,Port））</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span></span><br><span class="line">    serve=((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">5122</span>))</span><br><span class="line">    client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">    client.sendto(<span class="string">b&quot;Hello&quot;</span>,server)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>客户端可以不指定自己的（IP，Port），由操作系统自动分配（隐式绑定）</strong></li>
</ul>
<h2 id="UDP的recvfrom-与sendto"><a href="#UDP的recvfrom-与sendto" class="headerlink" title="UDP的recvfrom()与sendto()"></a>UDP的recvfrom()与sendto()</h2><ul>
<li>因为UDP是无连接协议（connectionless），因此需要用[from, to]来指明远端，除非使用了connect()绑定了UDP Socket<h4 id="①-socket-recvfrom-bufsize-flags"><a href="#①-socket-recvfrom-bufsize-flags" class="headerlink" title="① socket.recvfrom(bufsize[, flags])"></a>① socket.recvfrom(bufsize[, flags])</h4></li>
<li><strong>bufsize</strong>：接受bufsize大小（最大65535）的来自bind(address)所绑定的远端发来的字节数据</li>
<li><strong>返回值</strong>：发信方（bytes，address）的二元组，用bytes.decode(“UTF-8”)即可转化为字符（character），通过address可以知道是谁发来的字符（byte）</li>
</ul>
<h4 id="②-socket-sendto-bytes-address"><a href="#②-socket-sendto-bytes-address" class="headerlink" title="② socket.sendto(bytes, address)"></a>② socket.sendto(bytes, address)</h4><ul>
<li><strong>bytes</strong>：要发送的字节对象（Byte）</li>
<li><strong>address</strong>：接收方地址，由（IP，Port）二元组标识</li>
<li><strong>返回值</strong>：发送的字节数（number of bytes）</li>
</ul>
<h2 id="混杂发信端与垃圾回复"><a href="#混杂发信端与垃圾回复" class="headerlink" title="混杂发信端与垃圾回复"></a>混杂发信端与垃圾回复</h2><ul>
<li><strong>没有检查数据报的源地址的接受端（Receiver）程序是相当危险的，因为无法保证是可信发送端（Sender）的信息</strong>，比如小明向DNS服务器请求正向解析服务，如果没有鉴别回复消息是否来自可信DNS服务器，则很可能遭遇网络攻击。这与中间人攻击不同，中间人攻击需要获取网络控制权后从非法地址发送伪造数据报，可以使用加密来保护。而现在问题是，对于没有监测机制的接受端，所有操作都是合法的</li>
</ul>
<h2 id="使用connect-连接UDP-Socket"><a href="#使用connect-连接UDP-Socket" class="headerlink" title="使用connect()连接UDP Socket"></a>使用connect()连接UDP Socket</h2><ul>
<li><strong>UDP虽然是无连接（Connectionless），但不代表不能连接</strong></li>
<li><strong>对发信端（Sender）使用connect((IP_Receiver,Port_Receiver))显示绑定，可以解决发信端混杂性（promiscuous）</strong>，接收方（Receiver）会将来自非连接地址的数据报直接丢弃</li>
<li><strong>connect()一般只适用于同时与一台服务器交互的情景，重复运行connect()会覆盖之前的地址</strong></li>
<li>使用connect()连接UDP Socket并没有在网络上传输任何消息，也就是说“没有通知服务器”，只是<strong>将连接地址写入内存（memory）中</strong></li>
<li><strong>在connect()之后，可以使用面向连接的（send，recv）来替代（sendto，recvfrom）</strong>，也就是上层表现与TCP相似</li>
</ul>
<h2 id="区分bind-与connect"><a href="#区分bind-与connect" class="headerlink" title="区分bind()与connect()"></a>区分bind()与connect()</h2><ul>
<li>**bind()**：指定了要使用的特定端口</li>
<li>**connect()**：限制了回复人，只接受连接方的信息</li>
</ul>
<h2 id="UDP的不可靠性与recvfrom-的阻塞性"><a href="#UDP的不可靠性与recvfrom-的阻塞性" class="headerlink" title="UDP的不可靠性与recvfrom()的阻塞性"></a>UDP的不可靠性与recvfrom()的阻塞性</h2><ul>
<li><strong>UDP不保证传输的可靠性</strong>，这意味着如果需要确认消息是否被服务端（Server）收到，客户端（Client）必须在一个循环内发送请求，等待某个请求正确响应后，再发送其他请求，因此必须选择一个合适的等待时间</li>
<li><strong>无法通过UDP判断出服务器具体情况</strong>，因此客户端（Client）最好设定一定机制，确保在一定次数的尝试之后放弃</li>
<li><strong>使用 recvfrom()会阻塞网络调用</strong>，在没有收到信息之前会一直等待，<strong>可以通过 setblocking(False) 设置socket为非阻塞</strong></li>
</ul>
<h2 id="什么时候使用UDP"><a href="#什么时候使用UDP" class="headerlink" title="什么时候使用UDP"></a>什么时候使用UDP</h2><ul>
<li><p>① 只发送一条信息然后等待响应的服务（并不是小型信息UDP更高效，如果连续发送多条信息，可能需要“消息队列”，而消息队列往往是TCP，这与TCP中使用了Nagle算法有一定关系，详情见Chapter3.TCP）</p>
</li>
<li><p>② 实现了一个已经基于UDP的服务，比如DNS</p>
</li>
<li><p>③ 流媒体（Streaming Media），这类服务由于冗余性（redundancy）往往允许偶尔的丢包现象，却不能接受网络延迟</p>
</li>
<li><p>设计适用于LAN子网多播的应用程序</p>
<blockquote>
<blockquote>
<p>“当我们发现有一种适用UDP协议的应用程序时，我们很可能已经重新实现了TCP，并且实现得很糟糕！”</p>
</blockquote>
</blockquote>
</li>
</ul>
<h1 id="Chapter3-TCP-Transport-Control-Protocol"><a href="#Chapter3-TCP-Transport-Control-Protocol" class="headerlink" title="Chapter3. TCP (Transport Control Protocol)"></a>Chapter3. TCP (Transport Control Protocol)</h1><ul>
<li><strong>TCP是面向连接协议（Connection－oriented）</strong>，因此通过套接字对象，可以直接使用（send,recv）完成通信</li>
<li><strong>点对点</strong>（point-to-point），一个Sender对应一个Receiver</li>
<li><strong>可靠</strong>地传输<strong>有序</strong>的字节流，并且<strong>全双工（full duplex data）</strong></li>
<li><strong>TCP将发送和接收的数据看做流，没有开始或结束标记，可能发生数据传输不完整</strong>，而UDP只会接收到完整数据包</li>
<li>TCP会在<strong>传输中将数据流（data stream）分为多个大小不同的数据包（packet）然后在接收时重组</strong></li>
<li>现在除了协议设计专家，几乎没有人能够再改进线代TCP协议栈的性能</li>
</ul>
<h2 id="一个最简单的TCP-C-S程序"><a href="#一个最简单的TCP-C-S程序" class="headerlink" title="一个最简单的TCP C/S程序"></a>一个最简单的TCP C/S程序</h2><h4 id="服务端（Server）-1"><a href="#服务端（Server）-1" class="headerlink" title="服务端（Server）"></a>服务端（Server）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Server（先有Server才能有Client）</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个最简单的TCP Server</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#建立TCP套接字</span></span><br><span class="line">    server = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    server.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7788</span>))</span><br><span class="line">    <span class="comment">#开始监听端口，提供服务</span></span><br><span class="line">    server.listen(<span class="number">5</span>)<span class="comment">#最多同时挂起5个连接</span></span><br><span class="line">    </span><br><span class="line">    connector,addr = server.accept()<span class="comment">#接受并建立连接</span></span><br><span class="line">    mes = connector.recv(<span class="number">4096</span>)<span class="comment">#接受消息,最大4096Bytes</span></span><br><span class="line">    <span class="keyword">if</span> mes:<span class="comment">#Client在关闭连接时会发送一个NULL值，而python会解释为空字符串</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;From Client: &quot;</span>,mes)</span><br><span class="line">        connector.send(mes.upper())<span class="comment">#处理并回信</span></span><br><span class="line"></span><br><span class="line">    connector.close()<span class="comment">#关闭连接</span></span><br><span class="line">    server.close()<span class="comment">#关闭服务器</span></span><br></pre></td></tr></table></figure>

<h4 id="客户端（Client）-1"><a href="#客户端（Client）-1" class="headerlink" title="客户端（Client）"></a>客户端（Client）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Client（由Server提供（IP,Port））</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#建立TCP套接字</span></span><br><span class="line">    client = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    client.connect((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7788</span>))</span><br><span class="line">    <span class="comment">#发送字节流信息</span></span><br><span class="line">    mes = <span class="built_in">input</span>(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    client.send(mes.encode(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">    <span class="comment">#等待Server回复</span></span><br><span class="line">    response = client.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.decode(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">    <span class="comment">#关闭连接</span></span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>客户端可以不指定自己的（IP，Port），由操作系统自动分配（隐式绑定）</strong></li>
<li><strong>在TCP四次挥手时，最后会发送一个null的值，而python中没有此类型，所有python会解释为’’字符串，需要明确知道null 不等于空字符串</strong></li>
</ul>
<h2 id="三次握手-amp-四次挥手"><a href="#三次握手-amp-四次挥手" class="headerlink" title="三次握手 &amp; 四次挥手"></a>三次握手 &amp; 四次挥手</h2><p><img src="http://image.codebooklet.com/img_blog/Python/connectAndClose.png"></p>
<ul>
<li><strong>connect（握手）</strong>：在Client执行 connect() 时，会开始三次握手（左图）</li>
<li><strong>close connection（挥手）</strong>：任意一方执行 close() 时，会开始四次挥手（右图）</li>
</ul>
<h2 id="TIME-WAIT与SO-REUSEADDR套接字选项"><a href="#TIME-WAIT与SO-REUSEADDR套接字选项" class="headerlink" title="TIME_WAIT与SO_REUSEADDR套接字选项"></a>TIME_WAIT与SO_REUSEADDR套接字选项</h2><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><ul>
<li><strong>在四次挥手关闭连接socket的过程中</strong>，会经过 <strong>connect -&gt; TIME_WAIT -&gt;close</strong> 三个过程，而中间的<strong>TIME_WAIT过程是为了确保最后发送的ACK确认关闭消息能正确被对方收到</strong>，<strong>因此在关闭连接后，不能立即重新使用刚关闭的连接的端口</strong>，如果没有这个过程，可能导致未关闭方死等，或提前关闭方数据冲突（刚释放的端口被另一个进程使用，然后接受到了上一个进程应该接受的信息），<strong>这个过程一般持续2*MSL（Maximum Segment Life）</strong></li>
<li><strong>PS：Server的监听套接字（listening socket）可以立即关闭，并不会进入TIME_WAIT阶段</strong></li>
</ul>
<h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h4><ul>
<li><strong>使用socketopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)设定</strong>，设置之后<strong>使应用程序可以在连接处于TIME_WAIT状态时，使用正在关闭的端口</strong><blockquote>
<blockquote>
<p>Brandon Rhodes:”我在编写服务器代码时经常使用SO_REUSEADDR，从未遇到过任何问题”</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="被动套接字与主动套接字"><a href="#被动套接字与主动套接字" class="headerlink" title="被动套接字与主动套接字"></a>被动套接字与主动套接字</h2><h4 id="被动套接字（passive-socket）"><a href="#被动套接字（passive-socket）" class="headerlink" title="被动套接字（passive socket）"></a>被动套接字（passive socket）</h4><ul>
<li>又称<strong>监听套接字（listening socket）</strong>，<strong>一般由Server承担该角色</strong></li>
<li><strong>被动套接字由（IP，Port）标识，用于作为提供网络服务的入口，Server通过该入口来接受连接请求（connect）</strong></li>
<li>被动套接字<strong>不能用于发送或接收任何数据，也不标识任何实际的网络会话，只是个网络服务入口，让操作系统知道用哪个特定的TCP端口接受连接</strong></li>
</ul>
<h4 id="主动套接字（active-socket）"><a href="#主动套接字（active-socket）" class="headerlink" title="主动套接字（active socket）"></a>主动套接字（active socket）</h4><ul>
<li>又称<strong>连接套接字（connected socket）</strong>，<strong>一般由Client主动发起，然后同Server二者一起维护该 socket</strong></li>
<li><strong>主动套接字由（local_ip，local_port，remote_ip，remote_port）唯一与某一Server绑定</strong></li>
<li>主动套接字<strong>可以用于发送或接收数据</strong></li>
<li><strong>类似Unix系统的管道或文件，可以作为文件I/O中的输入流</strong></li>
</ul>
<h2 id="套接字方法分类"><a href="#套接字方法分类" class="headerlink" title="套接字方法分类"></a>套接字方法分类</h2><ol>
<li><strong>服务端套接字函数（Server Socket Methods）</strong>：只有listening Socket可以使用，比如 listen()</li>
<li><strong>客户端套接字函数（Client Socket Methods）</strong>：只用Connected Socket可以使用，比如 connect()</li>
<li><strong>连接套接字函数（Connected Socket Methods）</strong>：通过connect得到的socket可以使用，比如 getsockname()</li>
</ol>
<ul>
<li><a href="https://www.cnblogs.com/wu-wu/p/13784179.html">Python socket 常用方法分类与说明</a></li>
</ul>
<h2 id="TCP的listen-与accept"><a href="#TCP的listen-与accept" class="headerlink" title="TCP的listen()与accept()"></a>TCP的listen()与accept()</h2><ul>
<li>TCP的C/S架构可以用餐厅来类比，<strong>Server</strong>使用<strong>listen(N)<strong>开启餐厅（入口进程），N表示这家餐厅最多可以让多少客户同时排队等待用餐（不同于同时用餐，同时用餐人数取决于子进程数或线程数），因此至少为1。只要</strong>Client</strong>知道这个餐厅的地址就可以使用<strong>connect()<strong>来访问这家餐厅，在经过排队后，餐厅发起</strong>accept()<strong>，此时Client会被带到某一张餐桌（</strong>一个新建的socket</strong>）中开始用餐<strong>（send，recv）</strong></li>
</ul>
<h4 id="①-socket-listen-backlog"><a href="#①-socket-listen-backlog" class="headerlink" title="① socket.listen([backlog])"></a>① socket.listen([backlog])</h4><ul>
<li><strong>backlog</strong>：在accept()之前操作系统可以挂机的最大连接数，默认值是某个合理的值（a default reasonable value is chosen.）</li>
</ul>
<h4 id="②-accept"><a href="#②-accept" class="headerlink" title="② accept()"></a>② accept()</h4><ul>
<li><strong>注意</strong>：使用前必须对socket对象调用 bind() 和 listen()</li>
<li><strong>返回值</strong>：(conn, address) 前者是一个 socket object 后者是发起端的 address</li>
</ul>
<h2 id="TCP的connect"><a href="#TCP的connect" class="headerlink" title="TCP的connect()"></a>TCP的connect()</h2><ul>
<li><strong>不同于UDP，TCP的 connect() 是可能失败的（由于三次握手）</strong>，比如Server不应答或拒绝，或者收到RST（reset）数据包等情况</li>
<li><strong>由Client发起connect()，即Client主动（active socket）Server被动（passive socket）</strong></li>
<li><strong>操作系统通过（local_ip，local_port，remote_ip，remote_port）唯一标识Client</strong></li>
</ul>
<h4 id="①-socket-connect-address"><a href="#①-socket-connect-address" class="headerlink" title="① socket.connect(address)"></a>① socket.connect(address)</h4><ul>
<li><strong>address</strong>：远端socket的地址（Address of Server），形式取决于地址簇（address family）</li>
<li>**如果connection被中断（interrupted）可能会触发socket.timeout，对于非阻塞socket（non-blocking sockets）则会触发InterruptedError</li>
</ul>
<h2 id="TCP的recv-与send"><a href="#TCP的recv-与send" class="headerlink" title="TCP的recv()与send()"></a>TCP的recv()与send()</h2><ul>
<li>因为TCP是面向连接协议（connection-oriented），因此不需要在双方建立连接后再像UDP一样每次需要显式指定接收端</li>
</ul>
<h4 id="socket-recv-bufsize-flags"><a href="#socket-recv-bufsize-flags" class="headerlink" title="socket.recv(bufsize[, flags])"></a>socket.recv(bufsize[, flags])</h4><ul>
<li><strong>bufsize</strong>：一次最大可以接受的数据量，<strong>官方文档推荐使用一个相对较小的2的幂次方，比如4096</strong>，相关原因可能与缓存区&amp;MSS有关</li>
</ul>
<blockquote>
<blockquote>
<p>Note For best match with hardware and network realities, the value of bufsize should be a relatively small power of 2, for example, 4096.</p>
</blockquote>
</blockquote>
<ul>
<li><strong>flags</strong>：默认值是 0 ，一些可选参数详情见<a href="https://manpages.debian.org/recv(2)">Unix manual page</a></li>
<li><strong>返回值</strong>：一个表示接受到的数据的字节（Byte）对象</li>
</ul>
<h4 id="socket-send-bytes-flags"><a href="#socket-send-bytes-flags" class="headerlink" title="socket.send(bytes[, flags])"></a>socket.send(bytes[, flags])</h4><ul>
<li><strong>注意</strong>：使用前必须保证 socket 对象是连接（connect）过的</li>
<li><strong>bytes</strong>：要发送的字节流数据，<strong>需要应用层来保证数据传输完整性（或者使用sendall()）</strong></li>
<li><strong>flags</strong>：同recv()，默认值是 0 ，一些可选参数详情见<a href="https://manpages.debian.org/recv(2)">Unix manual page</a></li>
<li><strong>返回值</strong>：发送的字节流数据的字节数（Bytes）</li>
</ul>
<h2 id="建议使用sendall-而不是send"><a href="#建议使用sendall-而不是send" class="headerlink" title="建议使用sendall()而不是send()"></a>建议使用sendall()而不是send()</h2><h4 id="send-存在的问题"><a href="#send-存在的问题" class="headerlink" title="send()存在的问题"></a>send()存在的问题</h4><ul>
<li><p><strong>在调用一次send()时操作系统的网络栈可能会有以下3种情况发生</strong></p>
<p><strong>① 正常情况</strong>：网卡正好空闲，且有足够的发送缓存空间，<strong>将要发送的数据成功缓存并等待系统调用（system call）发送</strong></p>
<p><strong>② 失败情况</strong>：网卡忙碌，且发送缓存区满，操作系统也无法分出更多空间，<strong>此时send()默认会阻塞进程直到可以传输</strong></p>
<p><strong>③ 中间情况</strong>：发送缓存区几乎满，但尚有空间，<strong>此时部分数据可以进入发送缓存区队列等待发送，剩余数据则需等待</strong></p>
</li>
<li><p><strong>由于中间情况，调用send()时必须检查返回值，并且需要配合循环来使用</strong>，这样才能保证整个数据完整发送</p>
</li>
</ul>
<h4 id="sendall-的优势"><a href="#sendall-的优势" class="headerlink" title="sendall()的优势"></a>sendall()的优势</h4><ul>
<li>sendall()<strong>保证数据发送的完整性</strong></li>
<li>sendall()底层由C语言实现，比send()配合循环来发送数据<strong>更有效</strong></li>
<li>sendall()<strong>内部释放了Python的全局解释器锁（GIL，Global Interpreter Lock）因此其他Python线程在所有数据发送完成前不会竞争资源</strong></li>
</ul>
<h2 id="为什么Python标准库没有recv-相应的recvall-方法"><a href="#为什么Python标准库没有recv-相应的recvall-方法" class="headerlink" title="为什么Python标准库没有recv()相应的recvall()方法"></a>为什么Python标准库没有recv()相应的recvall()方法</h2><ul>
<li><strong>现在很少使用定长消息，不同协议对待部分到达的数据流的处理方法可能不同</strong></li>
<li><strong>用于处理recv()的循环往往比用于处理send()的循环更加复杂</strong>，因为即使程序知道还没有接收完整，也需要对已经接收的数据进行处理，而处理的细节不同应用场景也是不同的（突然想到之前操作系统期末的一道进程间同步互斥的主观题）</li>
</ul>
<h2 id="缓存区-amp-MSS"><a href="#缓存区-amp-MSS" class="headerlink" title="缓存区 &amp; MSS"></a>缓存区 &amp; MSS</h2><ul>
<li><strong>TCP的数据并不会直接被接受或发送，而是会暂存在网卡的缓存区（buffer）中</strong><br><img src="http://image.codebooklet.com/img_blog/Python/TCPbuffer.png"></li>
<li><strong>MSS（maximum segment size）</strong>，决定一个TCPsegment（TCP报文）的最大传输数据量，这个值通常会根据网卡链路层最大传输单元（MTU，maximum transmission unit）来设置，由于Ethernet和PPP的MTU为1500Bytes，且TCPHeader站40Bytes，通常MSS大小为1460Bytes</li>
<li><strong>注意MSS代表的是一个TCPsegment应用层最大数据传输量，而不是整个TCPsegment的最大大小</strong></li>
</ul>
<h2 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h2><h4 id="为什么会发生死锁"><a href="#为什么会发生死锁" class="headerlink" title="为什么会发生死锁"></a>为什么会发生死锁</h4><ul>
<li><strong>使用TCP时候，死锁现象是很容易发生的，因为通信双方很可能共享着彼此有限的资源——缓存区</strong></li>
<li><strong>即使接收端（Receiver）没有调用recv()，收到的数据也会暂存在缓存区，因此缓存区很容易满</strong></li>
<li><strong>写操作需要空间，在没有任何设定的情况下，当缓存区满时使用send()，默认阻塞进程，直到可以发送</strong></li>
<li>PS：UDP绝对不会发生上述情况，如果 datagram 超出接收端（Receiver）处理能力将会把超出部分丢弃，只能通过应用层检测丢失</li>
</ul>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ul>
<li><strong>Server使用recv()每次只处理一个较小的数据块是一个明智的选择，大小的选择通常是4096</strong></li>
<li><strong>使用锁（Lock）来控制读写的同步问题</strong></li>
<li><strong>使用多线程（multithread）或多进程（multiprocess）来处理接收或发送</strong></li>
</ul>
<h2 id="TCP如何量化Timeout"><a href="#TCP如何量化Timeout" class="headerlink" title="TCP如何量化Timeout"></a>TCP如何量化Timeout</h2><ul>
<li><strong>SampleRTT</strong>：衡量从segment发送到收到ACK的时间，<strong>是几次RTT的平均值</strong></li>
<li><strong>EstimatedRTT</strong> = ( 1 - α ) * EstimatedRTT + α * SampleRTT，通常 α = 0.125</li>
<li><strong>DevRTT</strong> = ( 1 - β ) * DevRTT + β *  | SampleRTT - EstimatedRTT |，通常 β = 0.25</li>
<li><strong>TimeoutInterval = EstimatedRTT + 4 * DevRTT</strong></li>
</ul>
<h2 id="TCP如何提供可靠连接"><a href="#TCP如何提供可靠连接" class="headerlink" title="TCP如何提供可靠连接"></a>TCP如何提供可靠连接</h2><ul>
<li><strong>每一个TCP数据包（packet）都有一个序列号（sequence numbers）</strong>，Client可以通过序列号对数据包正确排序，也可以从中发现丢失的数据包，从而请求重传</li>
<li><strong>序列号并不使用顺序的整数，序列号增长与数据包大小相关</strong>，比如某数据包packet[0]序列号为8000大小为1024Bytes，那么下一个数据包packet[1]的序列号就是9024</li>
<li><strong>起始序列号随机</strong>，防止被黑客轻易猜测到</li>
<li><strong>流量控制（flow control）</strong>，Client与Server会协商得到一个TCP窗口（window）大小，这个值决定了同时传输的数据量</li>
<li><strong>拥塞控制（congestion control）</strong>，如果发生丢包之类的情况，TCP会假定网路正在变得拥挤，然后基于一定算法减少每秒发送的数据量</li>
</ul>
<h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><h3 id="算法的思想与实际意义"><a href="#算法的思想与实际意义" class="headerlink" title="算法的思想与实际意义"></a>算法的思想与实际意义</h3><ul>
<li><strong>利用时间空间连续性，对发送间隔短或数据量极小的数据，先缓存再一起发送</strong></li>
<li>用于<strong>减少TCP/IP网络拥塞，提升网络性能</strong>，（比如一个仅仅1byte的数据直接发送，就需要加上40bytes的TCPHeader从而导致无效信息过多），但同时也带来<strong>粘包问题</strong></li>
</ul>
<h3 id="Nagle算法的规则"><a href="#Nagle算法的规则" class="headerlink" title="Nagle算法的规则"></a>Nagle算法的规则</h3><ul>
<li>① 如果包长度达到MSS，则允许发送</li>
<li>② 如果该包含有FIN，则允许发送</li>
<li>③ 若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送</li>
<li>④ 设置了<strong>TCP_NODELAY</strong>选项，则允许发送</li>
<li>⑤ 上述条件都未满足，但发生了超时（一般为200ms），则立即发送</li>
</ul>
<h2 id="粘包问题与解决方法"><a href="#粘包问题与解决方法" class="headerlink" title="粘包问题与解决方法"></a>粘包问题与解决方法</h2><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#还是上面的Server和Client代码只不过加了循环处理消息</span></span><br><span class="line"><span class="comment">#Client：</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client.send(<span class="string">b&quot;m&quot;</span>)</span><br><span class="line">        client.send(<span class="string">b&quot;m&quot;</span>)</span><br><span class="line">        response = client.recv(MTU)</span><br><span class="line">        <span class="built_in">print</span>(response.decode(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line"><span class="comment">#Server</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        mes = connector.recv(MTU)<span class="comment">#接受消息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;From Client: &quot;</span>,mes)</span><br><span class="line">        connector.send(mes.upper())<span class="comment">#处理并回信</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Terminal（Client）</span></span><br><span class="line">MMM</span><br><span class="line">MM</span><br><span class="line">M</span><br><span class="line">MMMM</span><br><span class="line"><span class="comment">#Terminal（Server）</span></span><br><span class="line">From Client:  b<span class="string">&#x27;mmm&#x27;</span></span><br><span class="line">From Client:  b<span class="string">&#x27;mm&#x27;</span></span><br><span class="line">From Client:  b<span class="string">&#x27;m&#x27;</span></span><br><span class="line">From Client:  b<span class="string">&#x27;mmmmm&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="Method-1：设置TCP-NODELAY"><a href="#Method-1：设置TCP-NODELAY" class="headerlink" title="Method 1：设置TCP_NODELAY"></a>Method 1：设置TCP_NODELAY</h4><h4 id="Method-2：向数据流加入特殊标识开始和结束（一般需要结合编码方式决定特殊标识）"><a href="#Method-2：向数据流加入特殊标识开始和结束（一般需要结合编码方式决定特殊标识）" class="headerlink" title="Method 2：向数据流加入特殊标识开始和结束（一般需要结合编码方式决定特殊标识）"></a>Method 2：向数据流加入特殊标识开始和结束（一般需要结合编码方式决定特殊标识）</h4><h4 id="Method-3：设置接收固定SIZE的数据，对小于该SIZE的数据补位"><a href="#Method-3：设置接收固定SIZE的数据，对小于该SIZE的数据补位" class="headerlink" title="Method 3：设置接收固定SIZE的数据，对小于该SIZE的数据补位"></a>Method 3：设置接收固定SIZE的数据，对小于该SIZE的数据补位</h4><h2 id="什么时候使用TCP"><a href="#什么时候使用TCP" class="headerlink" title="什么时候使用TCP"></a>什么时候使用TCP</h2><ul>
<li><strong>TCP几乎是互联网程序间进行通信的默认选择，可能在整个职业生涯中都不会有意使用UDP</strong></li>
</ul>
<h2 id="什么时候不使用TCP"><a href="#什么时候不使用TCP" class="headerlink" title="什么时候不使用TCP"></a>什么时候不使用TCP</h2><ul>
<li>Client向Server发送单个较小的请求，并且请求完成后不需要继续通信，避免握手挥手带来的额外数据包交换</li>
<li>在Client与Server不存在长时间连接需求的情况下</li>
<li>当丢包发生时，如果应用层（Application Layer）有比重传数据更聪明的方法来弥补的话（比如流媒体传输中的丢包可以通过一些压缩算法来补偿）可以选择UDP</li>
</ul>
<h1 id="附录（Appendix）"><a href="#附录（Appendix）" class="headerlink" title="附录（Appendix）"></a>附录（Appendix）</h1><h2 id="Python-Socket官方文档"><a href="#Python-Socket官方文档" class="headerlink" title="Python Socket官方文档"></a><a href="https://docs.python.org/3/library/socket.html">Python Socket官方文档</a></h2><h2 id="Python-Socket-常用方法"><a href="#Python-Socket-常用方法" class="headerlink" title="Python Socket 常用方法"></a><a href="https://www.cnblogs.com/wu-wu/p/13784179.html">Python Socket 常用方法</a></h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《Vulkan学习指南》笔记</title>
    <url>/2022/01/19/Vulkan/Vulkan%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>笔记内容来自《Vulkan学习之南》——Parminder Singh</li>
<li>只摘录了个人认为比较基础且核心的知识点，是原书的简化版</li>
</ul>
<span id="more"></span>

<h1 id="序章（Preface）"><a href="#序章（Preface）" class="headerlink" title="序章（Preface）"></a>序章（Preface）</h1><h2 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h2><ul>
<li><strong>Chapter1.</strong> ：Vulkan的基础概念以及编程模型</li>
<li><strong>Chapter2.</strong> ：Vulkan所必要的基础软件以及SDK</li>
<li><strong>Chapter3.</strong> ：设置开发环境，构建第一个Vulkan案例，详细讲解队列与队列族的概念，及其与逻辑设备的关系</li>
<li><strong>Chapter4.</strong> ：Vulkan的调试方法，使用验证层编写一个简单的例子，并且使用一些非标准的拓展属性</li>
<li><strong>Chapter5.</strong> ：深入Vulkan的指令缓存，了解指令池的作用，学习如何使用指令缓存进行录制，后半部分会讲内存管理，学习GPU内存的分配与销毁操作，理解CPU与GPU内存之间的映射关系</li>
<li><strong>Chapter6.</strong> ：图像资源与相关内存管理，包括图像创建、分配、绑定、映射，并使用这种方法创建一个深度图像进行深度测试。介绍WSI交换链，使用其实现渲染可绘制对象并展示到屏幕的功能，并尝试获取WSI交换链的颜色图像，并创建颜色视图以便绘制图元</li>
<li><strong>Chapter7.</strong> ：讨论缓存资源以及相关用途（即可绘制对象的几何体顶点缓存的构建），详细介绍使用渲染通道定义绘制操作的相关工作的方法，使用多个附件和子通道。使用渲染通道在Vulkan中实现帧缓存，用一个简单的示例演示如何清除背景颜色。在最后，将使用SPIR-V实现第一个Vulkan Shader Program并学习一些SDK工具的使用，将GLSL代码转换为SPIR-V的中间语言格式</li>
<li><strong>Chapter8.</strong> ：介绍Vulkan中的计算流水线和图形流水线，实现一个完整的图形流水线</li>
<li><strong>Chatpter9.</strong> ：全面介绍Vulkan中对象的绘制过程，讨论Vulkan中的同步机制，理解有关栅栏、信号量以及内存屏障的知识，此外将介绍如何绘制相关的API并通过一些简单的案例演示其用法</li>
<li><strong>Chapter10.</strong> ：介绍Vulkan对Shader资源的更新过程，用到了描述符和推送常数的概念，讨论描述符池和描述符集布局的创建过程。将学到有关流水线布局的用法，并使用描述符来更新设备内存端的缓存资源，将更新后的几何体渲染到屏幕上。与描述符不同的是，推送常数并不会使用指令缓存，而是使用一种更加优化的方式来更新资源，可以尝试实现一个简单的程序来深入理解推送常数的相关知识</li>
<li><strong>Chapter11.</strong> ：使用更加真实的方法（即贴纹理来渲染3D可绘制对象），将学习如何创建图像资源并为其设置采样器对象，还将学习使用线性和优化平铺的方式来更新纹理，在优化平铺模式下，用户还需要考虑使用传输缓存和图像内存的指令方法</li>
</ul>
<h1 id="Chapter1-开始学习新一代3D图形API"><a href="#Chapter1-开始学习新一代3D图形API" class="headerlink" title="Chapter1.开始学习新一代3D图形API"></a>Chapter1.开始学习新一代3D图形API</h1><blockquote>
<p>Vulkan是一款革命性的高性能3D图形和计算API，可用于现代GPU管线架构，能满足社区的最新需求。该API提供了一套全新的方法来克服传统API的复杂性和缺陷。<strong>Vulkan是一个显式API，保证用户在渲染时保持稳定平滑的帧速率，不会造成延迟或者故障</strong>。我们将简单了解Vulkan的生态系统，以及它的图形体系</p>
</blockquote>
<ul>
<li>（我将与OpenGL对比的部分内容略去，主要区别在于OpenGL通过状态机隐式管理资源，而Vulkan显式管理）</li>
</ul>
<h2 id="Vulkan及其演化史"><a href="#Vulkan及其演化史" class="headerlink" title="Vulkan及其演化史"></a>Vulkan及其演化史</h2><ul>
<li><a href="https://www.khronos.org/">Khronos</a>于2016发布了革命性的新架构Vulkan API，它充分利用了现代图形处理器单元的优势，来实现高性能图形和计算应用程序的开发</li>
<li>Vulkan的原始概念是由AMD基于它们的私有Mantle API设计和实现.AMD开源了自己的Mantle API并且贡献给Khronos组织。在多家硬件和软件供应商的协同帮助下，Khronos发布了Vulkan标准</li>
<li>Vulkan并不是目前唯一的新一代3D图形API，它还有多家不同的竞争者，例如Microsoft的Direct-X 12和Apple的Metal。不过，DirectX只能用于不同的Windows系统，而Metal只能用在Mac系统（OS X和iOS）。因此，Vulkan得以脱颖而出。它的跨平台特性可以支持所有现存的OS平台，其中已经包括了Windows（XP、Vista、7、8、10）、Linux、Tizen、SteamOS和Android、macOS 、iOS（最后两个是个人补充，2020年开始支持，可以说Vulkan基本上被所有主流PC系统支持）</li>
</ul>
<h2 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h2><table>
<thead>
<tr>
<th>Terms</th>
<th>中文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>1.Physical Device</td>
<td>物理设备</td>
<td>一台计算机系统包含多个支持Vulkan的物理硬件设备</td>
</tr>
<tr>
<td>2.Device</td>
<td>设备</td>
<td>设备是物理设备在应用程序中的逻辑表示</td>
</tr>
<tr>
<td>3.Queue</td>
<td>队列</td>
<td>队列表示执行引擎与应用程序之间的接口，一个物理设备总是包含1~N个队列（图形、计算、DMA/传输.etc）队列的职责是收集准备执行的工作（指令缓存）并分发到物理设备执行</td>
</tr>
<tr>
<td>4.Memory Type</td>
<td>内存类型</td>
<td>Vulkan暴露了多种内存类型，广义上可以分为两类：宿主内存（Host Memory）和设备内存（Device Memory）</td>
</tr>
<tr>
<td>5.Command</td>
<td>指令</td>
<td>每个指令都可以执行一些用户行为，广义上可以划分为：动作、状态设置、同步</td>
</tr>
<tr>
<td>6.Action Command</td>
<td>动作指令</td>
<td>包括绘制图元、清除表面、复制缓存、查询/时间戳操作，以及子通道的开始/结束操作，这些指令可以修改帧缓存附件、读取或写入内存（缓存或图像），以及写入查询池</td>
</tr>
<tr>
<td>7.Set State Command</td>
<td>状态设置指令</td>
<td>可以用来绑定流水线、描述字集合以及缓存，或者设置一个动作状态，以及渲染通道/子通道的状态</td>
</tr>
<tr>
<td>8.Synchronization Command</td>
<td>同步指令</td>
<td>用于处理多个动作指令（AC）同时发生的情况，用来设置同步或等待事件、插入流水线屏障对象，以及渲染通道/子通道的依赖</td>
</tr>
<tr>
<td>9.Command Buffer</td>
<td>指令缓存</td>
<td>一组指令的集合，可以记录多个指令并统一发送到队列中</td>
</tr>
</tbody></table>
<h2 id="Vulkan的原理"><a href="#Vulkan的原理" class="headerlink" title="Vulkan的原理"></a>Vulkan的原理</h2><h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><ul>
<li>支持Vulkan的系统都可以查询系统信息，返回可用的物理设备数量</li>
<li>每个物理设备支持一个或多个队列（Queue），队列被划分到不同的族群中</li>
<li>每个族群有特定功能（图形、计算、数据传输、内存管理等）</li>
<li>队列族群中的每个成员可以包含多个相似队列，互相兼容（可能在同一队列同时支持数据传输与图形操作）</li>
<li>Vulkan允许用户显式在应用程序中管理和控制内存，暴露设备支持的所有不同类型的内存堆（heap）</li>
<li>每个堆（heap）属于不同的内存区域</li>
<li>Vulkan应用程序需要负责控制一组Vulkan设备，将一系列指令记录到指令缓存（Command Buffer），并发送到队列（Queue），设备驱动会读取Queue并“in-order execute”</li>
<li>构建指令队列（结合后文个人认为这里指的是录制指令过程）代价较大，但是一旦完成就可以缓存和发送到队列中，根据需要多次执行</li>
<li>有些指令缓存（有限制）可以在应用程序中以多线程的方式并行构建</li>
</ul>
<p>[Vulkan执行模型（简化版）]</p>
<p><img src="http://image.codebooklet.com/img_blog/CG/default/image-20220119193307600.png" alt="image-20220119193307600"></p>
<blockquote>
<p>应用程序记录指令缓存，指令缓存包含多个指令，且按照作业性质不同，被传递给一个或多个队列，这些队列将缓存作业提交给设备加以执行。最后，设备处理得到结果，将结果显示到输出设备或者返回用户程序做进一步处理</p>
</blockquote>
<h3 id="用户应用程序主要职责"><a href="#用户应用程序主要职责" class="headerlink" title="用户应用程序主要职责"></a>用户应用程序主要职责</h3><ol>
<li>生产指令执行所必需的所有先决内容（资源准备、着色器编译、资源关联到着色器、设置着色器状态、构建流水线、绘制调用）</li>
<li>内存管理</li>
<li>同步（宿主和设备，设备上不同队列之间）</li>
<li>风险管理</li>
</ol>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul>
<li><p>Queue是Vulkan的一种中间层机制，负责接收指令缓存并传递给设备，指令缓存记录N条指令并发送到相关的队列。设备提供了多个可选队列，应用程序负责将Command Buffer传递给正确的Queue</p>
</li>
<li><p><strong>[ 单一队列 ]</strong> ：串行执行，按照指令缓存发送的顺序维护、执行、回放</p>
</li>
<li><p><strong>[ 多重队列 ]</strong> ：允许指令缓存并行地在多个队列中执行，如果不进行同步设置则无法保证实际执行顺序与发送指令顺序相同</p>
</li>
</ul>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><ul>
<li><strong>Semaphore（信号量）</strong> ： 粗粒度，可以在单一队列，也可以跨队列</li>
<li><strong>Event（事件）</strong> ： 细粒度，应用于单一队列，宿主系统可以参与到事件触发的同步机制</li>
<li><strong>Fence（栅栏）</strong> ： 允许在宿主和设备之间完成同步</li>
<li><strong>Pipeline Barrier（流水线屏障）</strong> ： 是一种插入到指令缓存中的指令，可以确保在他之前的指令始终优先执行，其余指令随后执行（分割先后，多个同时存在情况暂不确定）</li>
</ul>
<h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><ul>
<li>在应用端程序，设备、队列、指令缓存、帧缓存、流水线等内在的所有对象，统称为Vulkan对象</li>
<li>在内部API层面，Vulkan对象会被识别为不同的Handle（句柄）</li>
</ul>
<h4 id="1-可分发的句柄（Delegation）"><a href="#1-可分发的句柄（Delegation）" class="headerlink" title="1.可分发的句柄（Delegation）"></a>1.可分发的句柄（Delegation）</h4><ul>
<li>这类指针<strong>指向一个不透明的内部图形实体</strong>，不透明意味着不能直接访问内部结构体成员，只能通过API间接访问（PS：我感觉应该属于Delegation模式）</li>
<li>所有可分发句柄都会关联一个可分发类型，这样就可以将它本身作为参数传递给其他API指令</li>
<li><strong>典型示例：Vkinstance, VkCommandBuffer, VkPhtsicalDevice, VkDevice, VkQueue</strong></li>
</ul>
<h4 id="2-不可分发的句柄"><a href="#2-不可分发的句柄" class="headerlink" title="2.不可分发的句柄"></a>2.不可分发的句柄</h4><ul>
<li>这些64bits整型Handle<strong>不会指向结构体，而是直接包含对象本身信息</strong></li>
<li><strong>典型示例：VkSemaphore，VkFence，VkQueryPool，VkBufferView，VkDeviceMemory，VkBuffer，Vkimage，VkPipeline，VkShaderModule，VkSampler，VkRenderPass，VkDescriptorPool，VkDescriptorSetLayout，VkFramebuffer，VkPipelineCache，VkCommandPool，VkDescriptorSet，VkEvent，VkPipelineLayout，VkimageView</strong></li>
</ul>
<h3 id="对象生命周期与指令语法"><a href="#对象生命周期与指令语法" class="headerlink" title="对象生命周期与指令语法"></a>对象生命周期与指令语法</h3><ul>
<li><strong>Vulkan的对象是根据应用程序逻辑需求，显式地创建和销毁，应用程序需要自己管理这些对象</strong></li>
<li><strong>所有实现方法都可以通过vkGet*指令轻松获取</strong></li>
<li><strong>使用vkCmd*形式的API接口主要用于把指令记录到指令缓存中</strong></li>
</ul>
<h4 id="Create（vkCreate）"><a href="#Create（vkCreate）" class="headerlink" title="Create（vkCreate）"></a>Create（vkCreate）</h4><ul>
<li>需要一个Vk*Createinfo结构体作为参数</li>
</ul>
<h4 id="Destroy（vkDestroy）"><a href="#Destroy（vkDestroy）" class="headerlink" title="Destroy（vkDestroy）"></a>Destroy（vkDestroy）</h4><ul>
<li>每一个vkCreate都要对应一个Destroy</li>
</ul>
<p>如果对象是作为已有的对象池（Pool）或堆（Heap）的一部分创建的，那么需要使用Allocate指令创建，并使用Free指令从Pool或Heap中删除</p>
<h4 id="Allocate（vkAllocate-）"><a href="#Allocate（vkAllocate-）" class="headerlink" title="Allocate（vkAllocate*）"></a>Allocate（vkAllocate*）</h4><ul>
<li>一个对象如果是作为对象池的一部分创建，需要一Vk*AllocateInfo作为输入参数</li>
</ul>
<h4 id="Free（vkFree-）"><a href="#Free（vkFree-）" class="headerlink" title="Free（vkFree*）"></a>Free（vkFree*）</h4><ul>
<li>从对象池或者内存中释放</li>
</ul>
<h3 id="错误检查与验证"><a href="#错误检查与验证" class="headerlink" title="错误检查与验证"></a>错误检查与验证</h3><ul>
<li>Vulkan设计在性能最大化的前提下，提供了<strong>可选的错误检查和验证功能</strong></li>
<li>检错与验证可以在Vulkan的层次化结构中使用，在运行系统中实现多层间动态调试验证</li>
</ul>
<h2 id="理解Vulkan应用程序"><a href="#理解Vulkan应用程序" class="headerlink" title="理解Vulkan应用程序"></a>理解Vulkan应用程序</h2><ul>
<li>Vulkan的各种功能组件与彼此关系，以及如何用来构建一个Vulkan应用程序</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/Daily/default/image-20220125012254521.png" alt="image-20220125012254521"></p>
]]></content>
      <categories>
        <category>Vulkan</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>《Vulkan学习指南》练习题</title>
    <url>/2022/01/19/Vulkan/Vulkan%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>题目内容来自《Vulkan学习之南》——Parminder Singh</li>
<li>每章节的练习题纯个人设计，仅供参考，原书并没有课后练习题</li>
</ul>
<span id="more"></span>



<h1 id="Chapter1-开始学习新一代3D图形API"><a href="#Chapter1-开始学习新一代3D图形API" class="headerlink" title="Chapter1.开始学习新一代3D图形API"></a>Chapter1.开始学习新一代3D图形API</h1><h2 id="1-Vulkan-API的制定团队"><a href="#1-Vulkan-API的制定团队" class="headerlink" title="1.Vulkan API的制定团队"></a>1.Vulkan API的制定团队</h2><details><summary><b>▷ 参考答案</b></summary>
    Khronos
</details>

<h2 id="2-Physical-Device和Device的关系"><a href="#2-Physical-Device和Device的关系" class="headerlink" title="2.Physical Device和Device的关系"></a>2.Physical Device和Device的关系</h2><details><summary><b>▷ 参考答案</b></summary>
    一台计算机系统包含多个支持Vulkan的物理硬件设备，设备是物理设备在应用程序中的逻辑表示
</details>

<h2 id="3-Queue的定义和职责"><a href="#3-Queue的定义和职责" class="headerlink" title="3.Queue的定义和职责"></a>3.Queue的定义和职责</h2><details><summary><b>▷ 参考答案</b></summary>
    队列（Queue）表示执行引擎与应用程序之间的接口，一个物理设备总是包含1~N个队列（图形、计算、DMA/传输.etc）队列的职责是收集准备执行的工作（指令缓存）并分发到物理设备执行
</details>

<h2 id="4-Vulkan广义上有哪几类内存类型（Memory-Type）"><a href="#4-Vulkan广义上有哪几类内存类型（Memory-Type）" class="headerlink" title="4.Vulkan广义上有哪几类内存类型（Memory Type）"></a>4.Vulkan广义上有哪几类内存类型（Memory Type）</h2><details><summary><b>▷ 参考答案</b></summary>
    Vulkan暴露了多种内存类型，广义上可以分为两类：<br/>
    1.宿主内存（Host Memory）<br/>
    2.设备内存（Device Memory）
</details>

<h2 id="5-Command广义上可以划分为哪几类，简述各类指令的作用"><a href="#5-Command广义上可以划分为哪几类，简述各类指令的作用" class="headerlink" title="5.Command广义上可以划分为哪几类，简述各类指令的作用"></a>5.Command广义上可以划分为哪几类，简述各类指令的作用</h2><details><summary><b>▷ 参考答案</b></summary>
    每个指令都可以执行一些用户行为，广义上可以划分为：动作、状态设置、同步<br/>
    1.Action Command：绘制图元、清除表面、复制缓存、查询/时间戳、子通道开始/结束操作（这些指令可以修改帧缓存附件、读取或写入内存（缓存或图像）、写入查询池）<br/>
    2.Set State Command：绑定流水线、描述字集合、缓存，或设置一个动作状态、渲染通道/子通道的状态<br/>
    3.Syschronization Command：处理多个Action Command同时发生的情况，用于设置同步或等待事件、插入流水线屏障对象、渲染通道/子通道的依赖
</details>

<h2 id="6-Command-Buffer的定义和职责"><a href="#6-Command-Buffer的定义和职责" class="headerlink" title="6.Command Buffer的定义和职责"></a>6.Command Buffer的定义和职责</h2><details><summary><b>▷ 参考答案</b></summary>
    一组指令的集合，可以记录多个指令并统一发送到队列中（第3题）
</details>
]]></content>
      <categories>
        <category>Vulkan</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT标签页与分类页无法显示修复</title>
    <url>/2021/10/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/NexT%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B8%8E%E5%88%86%E7%B1%BB%E9%A1%B5%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><ul>
<li>使用NexT-6.0.0在_config中开启了categories与tags功能</li>
<li>使用hexo new page创建了对应的页面</li>
<li>给文章添加了categories与tags，但是没有在对应页面生成分类和标签</li>
</ul>
<span id="more"></span>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>需要在hexo new page之后，进入相应页面的index.md</li>
<li>在categories的index.md添加：type: “categories”</li>
<li>在tags的index.md添加：type: “tags”</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Codebooklet公告板</title>
    <url>/2021/10/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Bulletin-Board/</url>
    <content><![CDATA[<h2 id="2022-1-23"><a href="#2022-1-23" class="headerlink" title="2022/1/23"></a>2022/1/23</h2><ul>
<li>近期学习内容有点多，总感觉时间不够用，可能还是效率低吧</li>
</ul>
<span id="more"></span>

<h2 id="2022-1-19"><a href="#2022-1-19" class="headerlink" title="2022/1/19"></a>2022/1/19</h2><ul>
<li>期末考试+休息已经过去20天了，从今天起开始每日学习打卡</li>
</ul>
<h2 id="2021-12-28"><a href="#2021-12-28" class="headerlink" title="2021/12/28"></a>2021/12/28</h2><ul>
<li><p>“What our human emotions seem to require is the sight of struggle going on. The moment the fruits are being merely eaten things become ignoble. Sweat and effort, human nature strained to the utmost and on the rack yet getting through it alive, and then turning back to its success to pursue another more rare and arduous journey. This is the sort of thing that inspires us”</p>
<p>   -William James </p>
</li>
</ul>
<h2 id="2021-12-24"><a href="#2021-12-24" class="headerlink" title="2021/12/24"></a>2021/12/24</h2><ul>
<li>这学期修完数字图像处理、练习了几个网格处理算法后再看Games101，感觉又有新的收获！</li>
</ul>
<h2 id="2021-12-10"><a href="#2021-12-10" class="headerlink" title="2021/12/10"></a>2021/12/10</h2><ul>
<li>不得不说这学期实验是真的多，大大小小都算的话差不多30多个实验？想静下心来提炼整理的时间都没有，加上下个月准备找一份实习，现在还在忙着复习图形学基础和C++，太难了…</li>
</ul>
<h2 id="2021-11-26"><a href="#2021-11-26" class="headerlink" title="2021/11/26"></a>2021/11/26</h2><ul>
<li>准备了2个多月的JLPT N2考试居然因为疫情取消了！不过这样也好让我打好基础，后续准备考一次JTest，明年7月直接去考N1了！</li>
<li>近期各课程都开始实验课了，属实笔记整理时间有点影响，为了维持质量，下个月可能更新频率会更低一点</li>
</ul>
<h2 id="2021-11-21"><a href="#2021-11-21" class="headerlink" title="2021/11/21"></a>2021/11/21</h2><ul>
<li>挤出了一点时间把网络编程笔记完善了一下，现在从基础到UDP和TCP都整理差不多了</li>
<li>Eigen的Sparse Matrix很多细节还是不太清楚，等用熟练了再整理吧</li>
</ul>
<h2 id="2021-11-16"><a href="#2021-11-16" class="headerlink" title="2021/11/16"></a>2021/11/16</h2><ul>
<li>这周在做网络编程作业有点忙，好像有一整周没更新了，周末抽时间整理下网络编程的笔记</li>
</ul>
<h2 id="2021-11-7"><a href="#2021-11-7" class="headerlink" title="2021/11/7"></a>2021/11/7</h2><ul>
<li>这学期要研究Subdivision，论文读起来有些头疼（菜鸡落泪）感觉还有很多知识需要学习</li>
<li>由于网络编程课作业较多，C++STL的学习要暂缓了，这几周可能会发一些网络编程的内容</li>
</ul>
<h2 id="2021-11-1"><a href="#2021-11-1" class="headerlink" title="2021/11/1"></a>2021/11/1</h2><ul>
<li>这周准备学习C++的Eigen库和LaTeX，周末可以抽时间整理一些笔记</li>
<li>突然发现博客背景图片加载不了，结果居然是配置里面设置了https结果图床没有启用https</li>
</ul>
<h2 id="2021-10-31"><a href="#2021-10-31" class="headerlink" title="2021/10/31"></a>2021/10/31</h2><ul>
<li>近期由于学习某没有详细文档的框架，可能博客更新要暂缓了</li>
<li>讲道理再小的框架没有文档读起来也很头疼QAQ而且注释也不是详细</li>
</ul>
<h2 id="2021-10-24"><a href="#2021-10-24" class="headerlink" title="2021/10/24"></a>2021/10/24</h2><ul>
<li>Codebooklet 1024</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Codebooklet 搭建记录</title>
    <url>/2021/10/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/bloglog/</url>
    <content><![CDATA[<h2 id="2021-10-31"><a href="#2021-10-31" class="headerlink" title="2021/10/31"></a>2021/10/31</h2><ul>
<li>修复了博客翻页按钮错误 <a href="https://blog.csdn.net/weixin_45748734/article/details/106042522">参考文章</a></li>
</ul>
<h2 id="2021-10-28"><a href="#2021-10-28" class="headerlink" title="2021/10/28"></a>2021/10/28</h2><ul>
<li>开启了文章版权声明 <a href="https://cloud.tencent.com/developer/article/1482137">参考文章</a></li>
<li>修复了本站”分类”和”标签”功能（本站搜索：NexT标签页与分类页无法显示修复）</li>
<li>添加了置顶功能 <a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">参考文章</a></li>
<li>修复了文章目录无法跳转的BUG（修改post-details.js） <a href="https://www.cnblogs.com/Createsequence/p/14150758.html">参考文章</a></li>
</ul>
<span id="more"></span>

<h2 id="2021-10-24"><a href="#2021-10-24" class="headerlink" title="2021/10/24"></a>2021/10/24</h2><ul>
<li><p>隐藏网页底部 powered By Hexo / 强力驱动 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>浏览页面显示当前浏览进度 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>Local Search本地搜索 <a href="https://theme-next.iissnan.com/third-party-services.html">参考文章</a> </p>
</li>
<li><p>设置网站图标 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>Live2D <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>背景图片添加 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>修改页面加载特效 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>各版块透明度修改 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a> </p>
</li>
<li><p>代码块样式修改 <a href="http://pygo2.top/articles/3412/">参考文章</a></p>
</li>
<li><p>文章阅读量统计功能 <a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud">参考文章</a></p>
</li>
<li><p>侧边导航栏背景图替换 <a href="https://blog.csdn.net/qq_34003239/article/details/100883213">参考文章</a></p>
</li>
<li><p>修改侧边栏头像为圆形 <a href="https://www.codenong.com/js644264a8af2c/">参考文章</a></p>
</li>
<li><p>添加Valine评论 <a href="https://valine.js.org/quickstart.html">参考文章</a></p>
</li>
<li><p>启动了MathJax数学公式 <a href="https://theme-next.iissnan.com/third-party-services.html">参考文章</a></p>
</li>
<li><p>文章底部#变为图标 <a href="https://blog.csdn.net/as480133937/article/details/100138838">参考文章</a></p>
</li>
<li><p>开启了打赏功能 <a href="https://blog.csdn.net/lcyaiym/article/details/76796545">参考文章</a></p>
</li>
<li><p>打赏按钮更改为图标（本站搜索：NexT打赏按钮修改）</p>
</li>
</ul>
<h2 id="2021-10-23"><a href="#2021-10-23" class="headerlink" title="2021/10/23"></a>2021/10/23</h2><ul>
<li>参考<a href="https://theme-next.iissnan.com/getting-started.html">官方文档</a>完成了基本的设置</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT打赏按钮修改</title>
    <url>/2021/10/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%89%93%E8%B5%8F%E6%8C%89%E9%92%AE%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>简介：修改“Reward”功能的默认按钮CSS样式，最终效果和本站类似。（NexT Ver-6.0.0）</p>
<span id="more"></span>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><a href="#bottom" >点击跳转到本文末预览效果</a></p>
<h2 id="Step-1-找到CSS文件"><a href="#Step-1-找到CSS文件" class="headerlink" title="Step.1 找到CSS文件"></a>Step.1 找到CSS文件</h2><ul>
<li>打开本站目录</li>
<li>文件路径 /themes/next/source/css/_common/components/post/post-reward.styl</li>
<li>如果没有找到类似样式表文件，则本文无效</li>
</ul>
<h2 id="Step-2-准备新的按钮图片"><a href="#Step-2-准备新的按钮图片" class="headerlink" title="Step.2 准备新的按钮图片"></a>Step.2 准备新的按钮图片</h2><ul>
<li>需要两张，一张用于正常显示，另一张用于Hover时的显示</li>
<li>建议尺寸：50*50 pix （参考本站）</li>
<li>如果图片不是透明的，建议先使用PS先处理一下，并保存为支持透明通道的格式如PNG</li>
<li>存放图片到路径 /themes/next/source/images 中，也可以在此路径再新建文件夹归类，注意本文方法使用“本地存储图片”也就是说需要使用 相对路径 访问图片，一定要搞清楚目录层次</li>
</ul>
<h2 id="Step-3-修改CSS文件"><a href="#Step-3-修改CSS文件" class="headerlink" title="Step.3 修改CSS文件"></a>Step.3 修改CSS文件</h2><ul>
<li>修改第一步找到的样式表文件中的以下几个属性<br><strong>1. #rewardButton span</strong><ul>
<li>font-size: 0px; /* 这里是为了让“Reward”文字不显示 */</li>
<li>width: 50px; /* 请与自己处理好的按钮图片大小匹配  */</li>
<li>height: 50px; /* 请与自己处理好的按钮图片大小匹配  */</li>
<li>background: url(../../../../images/你的按钮图片路径); </li>
</ul>
<strong>2. #rewardButton span:hover</strong><ul>
<li>background:  url(../../../../images/icons/你的按钮Hover图片路径);</li>
</ul>
</li>
</ul>
<div id="bottom"></div>

<h2 id="Step-4-本地运行检测"><a href="#Step-4-本地运行检测" class="headerlink" title="Step.4 本地运行检测"></a>Step.4 本地运行检测</h2><ul>
<li>站点路径打开Terminal ：hexo s</li>
</ul>
<p><strong>Ps: 由于作者HTML/CSS水平仅限于了解，如果各位有更好的方法可以在评论区分享，谢谢！</strong></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP欺骗实验</title>
    <url>/2021/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>使用arpspoof对攻击目标发起ARP欺骗攻击，使攻击目标ARP表发生如下改变<br> （通信对象IP，通信对象MAC） ——&gt; （通信对象IP，<strong>攻击者MAC</strong>） </li>
</ul>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><h3 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h3><p><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/%E5%AE%9E%E9%AA%8C%E6%8B%93%E6%89%91.png" alt="p1"></p>
<h4 id="攻击目标（虚拟机）"><a href="#攻击目标（虚拟机）" class="headerlink" title="攻击目标（虚拟机）"></a>攻击目标（虚拟机）</h4><ul>
<li>操作系统：Windows10</li>
</ul>
<h4 id="通信目标（虚拟机）"><a href="#通信目标（虚拟机）" class="headerlink" title="通信目标（虚拟机）"></a>通信目标（虚拟机）</h4><ul>
<li>操作系统：CentOS</li>
</ul>
<h4 id="攻击者（宿主机）"><a href="#攻击者（宿主机）" class="headerlink" title="攻击者（宿主机）"></a>攻击者（宿主机）</h4><ul>
<li>操作系统 Kali</li>
</ul>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="局域网（LAN）中的信息传输过程"><a href="#局域网（LAN）中的信息传输过程" class="headerlink" title="局域网（LAN）中的信息传输过程"></a>局域网（LAN）中的信息传输过程</h3><ul>
<li>连接在以太网中的两台Terminal之间传输IP分组时，Sender必须先获取Receiver的MAC地址</li>
<li>每一个Terminal都有ARP缓冲区，用于保存（IP，MAC）的映射关系，如果Receiver在缓存区，则可以直接完成链路帧封装</li>
<li>如果Sender只有Receiver的IP地址，则需要通过“地址解析过程”获取Receiver的MAC，该过程通过ARP（Address Resolution Protocol）来实现</li>
</ul>
<h3 id="ARP地址解析过程"><a href="#ARP地址解析过程" class="headerlink" title="ARP地址解析过程"></a>ARP地址解析过程</h3><ul>
<li><p>Sender广播（broadcast）ARP请求报文，该报文格式如下</p>
<table>
<thead>
<tr>
<th align="center">帧校验序列</th>
<th align="center">数据（请求报文）</th>
<th align="center">类型</th>
<th align="center">源MAC地址</th>
<th align="center">目的MAC地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FCS</td>
<td align="center">（IP_A,MAC_A) , (IP_B, ? )</td>
<td align="center">ARP</td>
<td align="center">MAC A</td>
<td align="center">FF-FF-FF-FF-FF-FF</td>
</tr>
</tbody></table>
</li>
<li><p>在该LAN中的所有Terminals都记录下Sender的IP与MAC，但只有Receiver将自己（IP，MAC）回复给Sender</p>
</li>
<li><p>Sender收到回复消息，将其记录在自己的ARP缓存区</p>
</li>
</ul>
<h3 id="ARP欺骗原理"><a href="#ARP欺骗原理" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h3><ul>
<li>利用“ARP没有真伪校验”的特点，在ARP请求过程中，Hacker将IP对应的MAC修改为自己的MAC</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="Step-1-按照实验拓扑准备好虚拟机"><a href="#Step-1-按照实验拓扑准备好虚拟机" class="headerlink" title="Step.1 按照实验拓扑准备好虚拟机"></a>Step.1 按照实验拓扑准备好虚拟机</h3><ul>
<li>使用VMware完成虚拟机配置<br><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/0.%E5%87%86%E5%A4%87%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="p2"></li>
</ul>
<h3 id="Step-2-修改虚拟机网络模式为“桥接模式”"><a href="#Step-2-修改虚拟机网络模式为“桥接模式”" class="headerlink" title="Step.2 修改虚拟机网络模式为“桥接模式”"></a>Step.2 修改虚拟机网络模式为“桥接模式”</h3><ul>
<li><a href="http://www.codebooklet.com/2021/10/30/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA3%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/#more/">VMware的3种网络模式</a><br>![p3(<a href="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/1.%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%BA%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png">http://image.codebooklet.com/img_blog/ARP欺骗实验/1.修改虚拟机为桥接模式.png</a>)</li>
</ul>
<h3 id="Step-3-查看3方的网络配置"><a href="#Step-3-查看3方的网络配置" class="headerlink" title="Step.3 查看3方的网络配置"></a>Step.3 查看3方的网络配置</h3><h4 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h4><p><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/2.%E8%A2%AB%E6%94%BB%E5%87%BB%E8%80%85.png" alt="p4"></p>
<h4 id="通信目标"><a href="#通信目标" class="headerlink" title="通信目标"></a>通信目标</h4><p><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/3.%E6%B6%88%E6%81%AF%E7%9B%AE%E6%A0%87.png" alt="p5"></p>
<h4 id="攻击者"><a href="#攻击者" class="headerlink" title="攻击者"></a>攻击者</h4><p><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/4.%E6%94%BB%E5%87%BB%E6%96%B9.png" alt="p6"></p>
<h3 id="Step-4-查看当前攻击目标的ARP缓存"><a href="#Step-4-查看当前攻击目标的ARP缓存" class="headerlink" title="Step.4 查看当前攻击目标的ARP缓存"></a>Step.4 查看当前攻击目标的ARP缓存</h3><ul>
<li>Windows下使用“arp -a”即可，找到通信目标对应的映射<br><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/5.%E6%9F%A5%E7%9C%8B%E8%A2%AB%E6%94%BB%E5%87%BB%E8%80%85%E5%BD%93%E5%89%8DARP.png" alt="p7"></li>
</ul>
<h3 id="Step-5-发起攻击"><a href="#Step-5-发起攻击" class="headerlink" title="Step.5 发起攻击"></a>Step.5 发起攻击</h3><ul>
<li>使用“arpspoof”命令发起攻击</li>
</ul>
<p><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/6.%E5%8F%91%E8%B5%B7%E6%94%BB%E5%87%BB.png" alt="p8"><br/></p>
<table>
<thead>
<tr>
<th align="center">使用参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-i eth0</td>
<td align="center">使用 eth0 网卡发起攻击</td>
</tr>
<tr>
<td align="center">-t 10.66.217.60</td>
<td align="center">攻击目标IP为10.66.217.60</td>
</tr>
<tr>
<td align="center">-r 10.66.198.146</td>
<td align="center">伪造（IP：10.66.217.60，MAC：Hacker的MAC）的ARP请求</td>
</tr>
</tbody></table>
<h3 id="Step-6-查看攻击目标被攻击后的ARP表"><a href="#Step-6-查看攻击目标被攻击后的ARP表" class="headerlink" title="Step.6 查看攻击目标被攻击后的ARP表"></a>Step.6 查看攻击目标被攻击后的ARP表</h3><ul>
<li>可以发现IP：10.66.217.60 所对应的MAC已经变成了Hacker的MAC<br><img src="http://image.codebooklet.com/img_blog/ARP%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/7.%E8%A2%AB%E6%94%BB%E5%87%BB%E5%90%8E%E7%9A%84ARP%E8%A1%A8.png" alt="p9"></li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读论文了解新领域</title>
    <url>/2021/11/06/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87%E4%BA%86%E8%A7%A3%E6%96%B0%E9%A2%86%E5%9F%9F/</url>
    <content><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1A64y1v77W">斯坦福授课 | “如何有效阅读论文？并了解一个新的领域？——吴恩达</a></strong></p>
<span id="more"></span>

<hr>
<h2 id="论文阅读量与对该领域研究深度关系的一个参考指标"><a href="#论文阅读量与对该领域研究深度关系的一个参考指标" class="headerlink" title="论文阅读量与对该领域研究深度关系的一个参考指标"></a>论文阅读量与对该领域研究深度关系的一个参考指标</h2><h3 id="①-阅读5-20篇论文-Read-5-20-papers"><a href="#①-阅读5-20篇论文-Read-5-20-papers" class="headerlink" title="① 阅读5~20篇论文 (Read 5~20 papers)"></a>① 阅读5~20篇论文 (Read 5~20 papers)</h3><ul>
<li>对该领域有基本的了解，也许足够做一些工作并实现一些算法</li>
<li>A basic understanding of an area, maybe good enough to do some work, apply some algorithms</li>
</ul>
<h3 id="②-阅读50-100篇论文并有一定理解-Read-50-100-papers-and-a-kind-of-understand-a-lot-of-it"><a href="#②-阅读50-100篇论文并有一定理解-Read-50-100-papers-and-a-kind-of-understand-a-lot-of-it" class="headerlink" title="② 阅读50~100篇论文并有一定理解 (Read 50~100 papers and a kind of understand a lot of it)"></a>② 阅读50~100篇论文并有一定理解 (Read 50~100 papers and a kind of understand a lot of it)</h3><ul>
<li>可以说你已经足够了解这个领域</li>
<li>That’s probably enough to give you a very good understanding of an area</li>
</ul>
<hr>
<h2 id="如何开始新领域的研究？"><a href="#如何开始新领域的研究？" class="headerlink" title="如何开始新领域的研究？"></a>如何开始新领域的研究？</h2><h3 id="Step1-收集并整合相关资源"><a href="#Step1-收集并整合相关资源" class="headerlink" title="Step1. 收集并整合相关资源"></a>Step1. 收集并整合相关资源</h3><ul>
<li>先<strong>收集几篇该领域具有典型性的论文</strong>粗略地阅读，<strong>放弃一些有错误或者对你没有意义的论文</strong>并且<strong>找到你认为最具有开创性的论文深入阅读</strong></li>
</ul>
<h3 id="Step2-深入研究你认为与主题相关的任何资源"><a href="#Step2-深入研究你认为与主题相关的任何资源" class="headerlink" title="Step2. 深入研究你认为与主题相关的任何资源"></a>Step2. 深入研究你认为与主题相关的任何资源</h3><ul>
<li>通过这篇论文你可以<strong>在引用(citations)中找到其他相关的论文</strong>，阅读并回顾，充实对前面读过的文章的理解</li>
</ul>
<h3 id="Step3-做笔记提升对该领域的理解"><a href="#Step3-做笔记提升对该领域的理解" class="headerlink" title="Step3. 做笔记提升对该领域的理解"></a>Step3. 做笔记提升对该领域的理解</h3><hr>
<h2 id="如何阅读一篇论文？"><a href="#如何阅读一篇论文？" class="headerlink" title="如何阅读一篇论文？"></a>如何阅读一篇论文？</h2><blockquote>
<blockquote>
<p>When reading one paper the bad way to read it is to go from the first word until the last word.</p>
</blockquote>
</blockquote>
<h3 id="多次阅读论文-Multiple-passes-through-the-paper"><a href="#多次阅读论文-Multiple-passes-through-the-paper" class="headerlink" title="多次阅读论文 (Multiple passes through the paper)"></a>多次阅读论文 (Multiple passes through the paper)</h3><ul>
<li><strong>Step1.</strong> 阅读标题(Title)、摘要(Abstract)、图表(Figures)</li>
<li><strong>Step2.</strong> 阅读引言(Intro)、结论(Conclusions)掌握关键信息，并再次细致地看图表(Figures)，快速浏览论文中剩余的内容</li>
<li><strong>Step3.</strong> 对论文整体阅读，可以跳过不熟悉的数学公式、专业术语</li>
</ul>
<h3 id="通过回答一些问题检测自己对论文的理解程度"><a href="#通过回答一些问题检测自己对论文的理解程度" class="headerlink" title="通过回答一些问题检测自己对论文的理解程度"></a>通过回答一些问题检测自己对论文的理解程度</h3><ul>
<li><strong>Question1.</strong> 论文的作者们想要完成什么？已经完成了什么？(What did authors try to accomplish)</li>
<li><strong>Question2.</strong> 论文介绍的方法的关键要素是什么？(What were the key elements of the approach)</li>
<li><strong>Question3.</strong> 论文中哪些内容对你有用？(What can you use yourself)</li>
<li><strong>Question4.</strong> 你还想关注哪些参考文献？(What other references do you want to follow)</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>斯金纳箱（Skinner Box）</title>
    <url>/2021/12/26/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%96%AF%E9%87%91%E7%BA%B3%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="斯金纳箱（Skinner-Box）"><a href="#斯金纳箱（Skinner-Box）" class="headerlink" title="斯金纳箱（Skinner Box）"></a>斯金纳箱（Skinner Box）</h1><ul>
<li>斯金纳箱（Skinner box）是心理学实验装置。<a href="https://baike.baidu.com/item/%E8%A1%8C%E4%B8%BA%E4%B8%BB%E4%B9%89/1750752">行为主义</a>者<a href="https://baike.baidu.com/item/%E6%96%AF%E9%87%91%E7%BA%B3/342663">斯金纳</a>1938年发明，并于动物操作条件作用实验。该装置实际是对<a href="https://baike.baidu.com/item/%E6%A1%91%E4%BB%A3%E5%85%8B%E8%BF%B7%E7%AE%B1/22373711">桑代克迷箱</a>的改进，后被用于研究动物学习能力和自我刺激与合作行为等心理学研究</li>
<li>意义：操作性条件反射理论</li>
<li><a href="https://baike.baidu.com/item/%E6%96%AF%E9%87%91%E7%BA%B3%E7%AE%B1/5378961">参考文章-百度百科</a></li>
</ul>
<span id="more"></span>



<h2 id="奖励-amp-惩罚"><a href="#奖励-amp-惩罚" class="headerlink" title="奖励&amp;惩罚"></a>奖励&amp;惩罚</h2><h3 id="实验①：不断奖励可以培养行为习惯"><a href="#实验①：不断奖励可以培养行为习惯" class="headerlink" title="实验①：不断奖励可以培养行为习惯"></a>实验①：不断奖励可以培养行为习惯</h3><ul>
<li><p><strong>将一只很饿的小白鼠放入一个有按钮的箱中，每次按下按钮，则掉落食物</strong></p>
</li>
<li><p><strong>结果：小白鼠自发学会了按按钮</strong></p>
</li>
<li><p><strong>结论：何为学习——将行为与操作者的需求建立相倚性联系。换句话说，使行为者感觉到“行为”与“奖励”是有联系的，只要通过将行为与奖励不断重复、建立联系，就可以培养起操作者的行为模式</strong></p>
</li>
</ul>
<h3 id="实验②：不断惩罚可以培养行为习惯"><a href="#实验②：不断惩罚可以培养行为习惯" class="headerlink" title="实验②：不断惩罚可以培养行为习惯"></a>实验②：不断惩罚可以培养行为习惯</h3><ul>
<li><p><strong>将一只小白鼠放入一个有按钮的箱中。每次小白鼠不按下按钮，则箱子通电</strong></p>
</li>
<li><p><strong>结果：小白鼠自发学会了按按钮，但遗憾的是，一旦箱子不再通电，小白鼠按按钮的行为迅速消失</strong></p>
</li>
<li><p><strong>结论：“惩罚”作为奖励的邪恶双生子，可以迅速建立行为模式。然而，惩罚具有一定的副作用：它建立起来的行为模式，来得快，去得也快。一旦惩罚消失，则行为模式也会迅速消失。从长远来看，惩罚对于行为的制止并不会起到显著作用。现实生活中，因为惩罚带来的凡勃伦效应，有时甚至会使惩罚起反作用</strong></p>
</li>
</ul>
<h3 id="凡勃伦效应（Veblen-Effect）"><a href="#凡勃伦效应（Veblen-Effect）" class="headerlink" title="凡勃伦效应（Veblen Effect）"></a>凡勃伦效应（Veblen Effect）</h3><ul>
<li>美国学者凡勃伦认为，与产品越降价、需求越增多的一般规律不同，<strong>特定的产品越涨价，需求越增多</strong>。部分上流阶层的消费目的在于，炫耀自己的社会地位和成功，满足虚荣心，所以价格越高，需求则增加。相反，如果降价，体现上流阶层的界限变得模糊，所以需求减少</li>
<li><a href="https://baike.baidu.com/item/%E5%87%A1%E5%8B%83%E4%BC%A6%E6%95%88%E5%BA%94/10857931">百度百科——凡勃伦效应</a></li>
</ul>
<h3 id="对于这两个实验的思考"><a href="#对于这两个实验的思考" class="headerlink" title="对于这两个实验的思考"></a>对于这两个实验的思考</h3><ul>
<li><strong>“惩罚性学习”具有短时性，而“奖励性学习”的收益慢但也更持久</strong>，比如在背单词的时候，比起立一个“今天不背100个单词不睡觉”的惩罚性Flag，“今天背完100个单词奖励自己玩会游戏”的奖励性Flag可能对长期学习有效，<strong>不过在实际中，我认为需要结合地使用：人通常是具有惰性的，而惩罚性学习可以迅速建立行为模式，因此应该利用适当惩罚来建立学习习惯，并通过奖励机制持久化学习</strong>，回想起之前考CET6时每天背单词打卡的经历，确实一开始是通过朋友圈监督才建立起习惯，而后面慢慢变成由背单词带来的收获感激励每天学习</li>
<li><strong>惩罚可能会由于凡勃伦效应而起到反作用</strong>，这句话我理解了很久，但最后发现其实结合“考试后摆烂”的现实问题就很好理解了，对于处于“惩罚性学习”中的人来说，因此一旦惩罚结束，就丧失了学习的意义。此外在百度百科中提到了“艺术品消费行为与凡勃伦效应”，确实非常具有现实意义。而且拓展地思考一下，其实当下考研热潮也是凡勃伦效应的体现，随着考研人数的不断增加，考研也变得“昂贵起来”，但是每年的考研人数却仍然飞速上涨…</li>
</ul>
<h2 id="必然-amp-偶然"><a href="#必然-amp-偶然" class="headerlink" title="必然&amp;偶然"></a>必然&amp;偶然</h2><h3 id="实验③：固定时间奖励"><a href="#实验③：固定时间奖励" class="headerlink" title="实验③：固定时间奖励"></a>实验③：固定时间奖励</h3><ul>
<li><strong>将一只很饿的小白鼠放入斯金纳箱中，由一开始的一直掉落食物，逐渐降低到每1分钟后，按下按钮可概率掉落食物</strong></li>
<li><strong>结果：小白鼠一开始不停按钮。过一段时间之后，小白鼠学会了间隔1分钟按一次按钮，但是当掉落食物停止时，小白鼠的行为消失</strong></li>
<li><strong>结论：当行为者明确知道当前的行为是否会产生期望的结果时，通常会做出理智的判断</strong></li>
</ul>
<h3 id="实验④：概率型奖励"><a href="#实验④：概率型奖励" class="headerlink" title="实验④：概率型奖励"></a>实验④：概率型奖励</h3><ul>
<li><p><strong>将一只很饿的小白鼠放入斯金纳箱中，多次按下按钮，概率掉落食物</strong></p>
</li>
<li><p><strong>结果：小白鼠学会了不停按钮，当不再掉落食物时，小白鼠的学习行为消失速度非常慢</strong></p>
</li>
<li><p><strong>结论：由于概率性给予结果，行为者很难直观地判断机制是否失效，所以单次的失败不会给予明显的“惩罚”效果，终止行为者的习惯，从而行为者的学习行为会一直持续下去</strong></p>
</li>
</ul>
<h3 id="概率下产生的奇特行为"><a href="#概率下产生的奇特行为" class="headerlink" title="概率下产生的奇特行为"></a>概率下产生的奇特行为</h3><ul>
<li><strong>在“概率型奖励”实验中，小白鼠有很多培养出了奇特的行为习惯，比如撞箱子、比如作揖、比如转圈跳舞，这是因为掉落食物前，小白鼠正好在进行这些行为，于是产生了“迷信”</strong></li>
</ul>
<h3 id="实验意义"><a href="#实验意义" class="headerlink" title="实验意义"></a>实验意义</h3><blockquote>
<p>斯金纳通过实验发现，动物的学习行为是随着一个起强化作用的刺激而发生的。斯金纳把动物的学习行为推而广之到人类的学习行为上，他认为虽然人类学习行为的性质比动物复杂得多，但也要通过<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%80%A7%E6%9D%A1%E4%BB%B6%E5%8F%8D%E5%B0%84/2041911">操作性条件反射</a>。操作性条件反射的特点是：强化刺激既不与反应同时发生，也不先于反应，而是随着反应发生。有机体必须先作出所希望的反应，然后得到“报酬”，即强化刺激，使这种反应得到强化。学习的本质不是刺激的替代，而是反应的改变。斯金纳认为，人的一切行为几乎都是操作性强化的结果，人们有可能通过强化作用的影响去改变别人的反应。在教学方面教师充当学生行为的设计师和建筑师，把学习目标分解成很多小任务并且一个一个地予以强化，学生通过操作性条件反射逐步完成学习任务</p>
</blockquote>
<h3 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h3><ul>
<li><p><strong>任务的阶段划分非常重要</strong>，在学习等任务中，如果一开始好高骛远，那么在任务还没有开始执行者一般就会知道是否可以完成，也就是说符合实验③的结论，而阶段的划分一般需要熟悉该邻域的专家——比如学习中如果有一个好老师将会事半功倍，如果没有这种专家指导，那么最好的选择是<strong>一开始不要对自己期望过高</strong></p>
</li>
<li><p><strong>把握确定的事情，对不确定的事情保持理性，特别当为了不确定的结果而放弃确定的结果时</strong>，让我想起了《乱世佳人，Gone with the Wind》中瑞德那句“很抱歉斯嘉丽，你亲手扔掉了已经得到的幸福，转而追逐永远得不到的幸福”</p>
</li>
</ul>
<blockquote>
<p>You know, i’m sorry for you ,Scarlett. Sorry for you because you throw away happiness with both hands and reach out for something that will never make you happy.</p>
</blockquote>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware虚拟机3种网络模式</title>
    <url>/2021/10/30/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA3%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>VMware虚拟机提供3种网络模式</strong></p>
<ol>
<li>桥接模式（Bridged）</li>
<li>网络地址转换模式（NAT）</li>
<li>主机模式（Host-only）<span id="more"></span></li>
</ol>
<table>
<thead>
<tr>
<th>模式</th>
<th>依赖的网络服务</th>
<th>虚拟网络组成</th>
<th>访问外部网络的方式</th>
<th>与宿主机互访方式</th>
</tr>
</thead>
<tbody><tr>
<td>桥接模式</td>
<td>VMnet0（虚拟网桥）</td>
<td>相当于宿主机局域网内一台独立主机</td>
<td>虚拟网桥联网</td>
<td>同一局域网</td>
</tr>
<tr>
<td>NAT模式</td>
<td>VMnet8（虚拟网卡）</td>
<td>虚拟DHCP + 虚拟交换机 + 虚拟NAT</td>
<td>虚拟NAT联网</td>
<td>与宿主机不在同一网段，通过虚拟网卡</td>
</tr>
<tr>
<td>主机模式</td>
<td>VMnet1（虚拟网卡）</td>
<td>虚拟DHCP + 虚拟交换机</td>
<td>通过宿主机转发到虚拟网卡</td>
<td>与宿主机不在同一网段，通过虚拟网卡</td>
</tr>
</tbody></table>
<ul>
<li><strong>★ 需要开启什么模式就要将对应的虚拟网卡启动！</strong></li>
<li><a href="https://www.cnblogs.com/linjiaxin/p/6476480.html">参考文章（详细解释推荐看此篇文章）</a></li>
</ul>
<h1 id="桥接模式（Bridged）"><a href="#桥接模式（Bridged）" class="headerlink" title="桥接模式（Bridged）"></a>桥接模式（Bridged）</h1><h3 id="适用情况：让虚拟机中的操作系统为它所在的局域网（LAN）提供网络服务"><a href="#适用情况：让虚拟机中的操作系统为它所在的局域网（LAN）提供网络服务" class="headerlink" title="适用情况：让虚拟机中的操作系统为它所在的局域网（LAN）提供网络服务"></a>适用情况：让虚拟机中的操作系统为它所在的局域网（LAN）提供网络服务</h3><ul>
<li>虚拟机相当于局域网中的一台独立主机</li>
<li>可以独立访问网络中其他主机</li>
<li>TCP/IP配置信息由VMnet0提供，不支持DHCP服务</li>
<li>IP地址必须和宿主机在同一网段，否则无法与宿主机通信</li>
</ul>
<h1 id="网络地址转换模式（NAT）"><a href="#网络地址转换模式（NAT）" class="headerlink" title="网络地址转换模式（NAT）"></a>网络地址转换模式（NAT）</h1><h3 id="适用情况：希望让虚拟机简单地接入互联网（只要宿主机能接入互联网即可）"><a href="#适用情况：希望让虚拟机简单地接入互联网（只要宿主机能接入互联网即可）" class="headerlink" title="适用情况：希望让虚拟机简单地接入互联网（只要宿主机能接入互联网即可）"></a>适用情况：希望让虚拟机简单地接入互联网（只要宿主机能接入互联网即可）</h3><ul>
<li>虚拟机通过NAT通过宿主机所在的局域网来访问互联网</li>
<li>TCP/IP配置由VMnet8自动配置，无法进行手工修改</li>
<li><strong>无法与他所在的局域网中的其他主机进行通信</strong></li>
</ul>
<h1 id="主机模式（Host-only）"><a href="#主机模式（Host-only）" class="headerlink" title="主机模式（Host-only）"></a>主机模式（Host-only）</h1><h3 id="适用情况：需要将真实网络与虚拟网络隔离进行特殊网络调试"><a href="#适用情况：需要将真实网络与虚拟网络隔离进行特殊网络调试" class="headerlink" title="适用情况：需要将真实网络与虚拟网络隔离进行特殊网络调试"></a>适用情况：需要将真实网络与虚拟网络隔离进行特殊网络调试</h3><ul>
<li>所有虚拟机之间可以互相通信，但<strong>虚拟系统和真实网络互相隔离</strong></li>
<li>TCP/IP配置由VMnet1提供</li>
<li>可以与宿主机互相通信</li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>DOS攻击实验LOIC+XAMPP</title>
    <url>/2021/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>使用LOIC与XAMPP对虚拟机发起TCP协议拒绝服务攻击（DOS）</li>
</ul>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><h4 id="被攻击者（虚拟机）"><a href="#被攻击者（虚拟机）" class="headerlink" title="被攻击者（虚拟机）"></a>被攻击者（虚拟机）</h4><ul>
<li>操作系统：CentOS</li>
<li>软件：XAMPP for Linux 7.4.25</li>
<li>动作：使用XAMPP在80端口开启Apache服务</li>
</ul>
<h4 id="攻击者"><a href="#攻击者" class="headerlink" title="攻击者"></a>攻击者</h4><ul>
<li>操作系统：Windows10</li>
<li>软件：LOIC-1.0.8</li>
<li>动作：使用LOIC向虚拟机发起TCP协议DOS攻击</li>
</ul>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><ul>
<li><p>本实验采用<strong>TCP协议DOS攻击</strong>，TCP是“面向连接”的协议，与服务器链接使会<strong>三次握手</strong></p>
<table>
<thead>
<tr>
<th align="left">三次握手</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">① <strong>Client    &gt;  (SYN)   &gt;   Server</strong></td>
<td align="left">客户端发起请求</td>
</tr>
<tr>
<td align="left">② <strong>Client    &lt;   (SYN+ACK)   &lt;    Server</strong></td>
<td align="left">服务端创建线程处理请求并等待客户端回复</td>
</tr>
<tr>
<td align="left">③ <strong>Client    &gt;   (ACK)   &gt;    Server</strong></td>
<td align="left">客户端回复确认</td>
</tr>
</tbody></table>
</li>
<li><p>如果Client一直没有回复，则Server会不断重新发送请求，这段时间称为”SYN Timeout”通常持续30~120秒（可以在服务器配置中修改）</p>
</li>
<li><p>因此如果短时间内服务器接收大量请求，将会耗尽服务器资源无法提供正常服务</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="Step-1-被攻击者（虚拟机）环境配置"><a href="#Step-1-被攻击者（虚拟机）环境配置" class="headerlink" title="Step.1 被攻击者（虚拟机）环境配置"></a>Step.1 被攻击者（虚拟机）环境配置</h3><h4 id="1-下载XAMPP"><a href="#1-下载XAMPP" class="headerlink" title="1.下载XAMPP"></a>1.下载XAMPP</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/1.%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E4%B8%8B%E8%BD%BDXAMPP.png"></img></p>
<h4 id="2-使用”chmod-x”添加可执行权限并以superuser身份启动安装"><a href="#2-使用”chmod-x”添加可执行权限并以superuser身份启动安装" class="headerlink" title="2.使用”chmod +x”添加可执行权限并以superuser身份启动安装"></a>2.使用”chmod +x”添加可执行权限并以superuser身份启动安装</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/2.%E4%BF%AE%E6%94%B9%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E6%9D%83%E9%99%90.png"></img><br><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/4.%E5%88%87%E6%8D%A2%E8%87%B3root%E5%90%AF%E5%8A%A8.png"></img></p>
<h4 id="3-使用XAMPP在80端口开启Apache服务"><a href="#3-使用XAMPP在80端口开启Apache服务" class="headerlink" title="3.使用XAMPP在80端口开启Apache服务"></a>3.使用XAMPP在80端口开启Apache服务</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/5.%E5%BC%80%E5%90%AFApache%E6%9C%8D%E5%8A%A1%E5%9C%A880%E7%AB%AF%E5%8F%A3.png"></img></p>
<h4 id="4-使用”systemctl-stop-firewalld-service”关闭防火墙"><a href="#4-使用”systemctl-stop-firewalld-service”关闭防火墙" class="headerlink" title="4.使用”systemctl stop firewalld.service”关闭防火墙"></a>4.使用”systemctl stop firewalld.service”关闭防火墙</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/12.%E5%85%B3%E9%97%AD%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%98%B2%E7%81%AB%E5%A2%99.png"></img></p>
<h4 id="5-使用”ifconfig”查看虚拟机的IP并记录"><a href="#5-使用”ifconfig”查看虚拟机的IP并记录" class="headerlink" title="5.使用”ifconfig”查看虚拟机的IP并记录"></a>5.使用”ifconfig”查看虚拟机的IP并记录</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/6.%E6%9F%A5%E7%9C%8BTarget%E7%9A%84IP.png"></img></p>
<h3 id="Step-2-攻击者环境配置"><a href="#Step-2-攻击者环境配置" class="headerlink" title="Step.2 攻击者环境配置"></a>Step.2 攻击者环境配置</h3><h4 id="1-下载LOIC"><a href="#1-下载LOIC" class="headerlink" title="1.下载LOIC"></a>1.下载LOIC</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/7.%E4%B8%8B%E8%BD%BDLOIC.png"></img></p>
<ul>
<li>可以在其他资源站点下载该软件，此处图片只为效果展示</li>
</ul>
<h4 id="2-配置攻击信息"><a href="#2-配置攻击信息" class="headerlink" title="2.配置攻击信息"></a>2.配置攻击信息</h4><ul>
<li>IP：虚拟机的IP</li>
<li>Port：80</li>
<li>Method：TCP</li>
<li>Thread和Speed可以自行调整，Thread不能过大<br><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/8.%E9%85%8D%E7%BD%AE%E6%94%BB%E5%87%BB%E4%BF%A1%E6%81%AF.png"></img></li>
</ul>
<h3 id="Step-3-监测虚拟机系统资源并发起攻击"><a href="#Step-3-监测虚拟机系统资源并发起攻击" class="headerlink" title="Step.3 监测虚拟机系统资源并发起攻击"></a>Step.3 监测虚拟机系统资源并发起攻击</h3><h4 id="1-虚拟机使用”vmstat”监测系统资源"><a href="#1-虚拟机使用”vmstat”监测系统资源" class="headerlink" title="1.虚拟机使用”vmstat”监测系统资源"></a>1.虚拟机使用”vmstat”监测系统资源</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/11.%E8%A2%AB%E6%94%BB%E5%87%BB%E8%80%85%E7%8A%B6%E6%80%81.png"></img></p>
<h4 id="2-攻击方点击Lock-on并发起攻击"><a href="#2-攻击方点击Lock-on并发起攻击" class="headerlink" title="2. 攻击方点击Lock on并发起攻击"></a>2. 攻击方点击Lock on并发起攻击</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/10.%E7%82%B9%E5%87%BB%E9%94%81%E5%AE%9A%E7%9B%AE%E6%A0%87%E5%B9%B6%E5%BC%80%E5%A7%8B%E6%94%BB%E5%87%BB.png"></img></p>
<h4 id="3-观察虚拟机系统资源状态变化情况"><a href="#3-观察虚拟机系统资源状态变化情况" class="headerlink" title="3.观察虚拟机系统资源状态变化情况"></a>3.观察虚拟机系统资源状态变化情况</h4><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/13.%E6%AD%A4%E6%97%B6%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8A%B6%E6%80%81.png"></img></p>
<ul>
<li>可以发现CPU开始繁忙，且IO与swap的使用量也上涨到了一个恐怖的数级，System的中断与上下文切换也变得非常频繁，最终结果——宕机 <a href="http://www.codebooklet.com/2021/10/29/Linux/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/#vmstat">vmstat命令介绍</a></li>
</ul>
<h3 id="TCP协议DOS攻击效果展示"><a href="#TCP协议DOS攻击效果展示" class="headerlink" title="TCP协议DOS攻击效果展示"></a>TCP协议DOS攻击效果展示</h3><p><img src="http://image.codebooklet.com/img_blog/DOS%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8CLOIC-XAMPP/DOS%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif"></img></p>
<ul>
<li>可以看出来被攻击者访问127.0.0.1的速度逐渐下降最后无法访问，甚至宕机</li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>《这才是心理学》</title>
    <url>/2021/11/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%BF%99%E6%89%8D%E6%98%AF%E5%BF%83%E7%90%86%E5%AD%A6%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>书名：这才是心理学(第11版)</li>
<li>作者：<a href="http://keithstanovich.com/Site/Home.html">基思·斯坦诺维奇</a></li>
</ul>
<p>学校的阅读周活动的推荐读物，整体上偏向科普类读物而不是专业研究读物，作者希望即使读者最终将书中所有心理科学的内容全部忘记了，也可以通过这本书学习到心理科学中研究的方法，比如说批判性的思维等。作者强调心理学是一种科学，因此我认为心理学的思维方法在其他科学领域中也有重要的参考价值，所以本笔记将结合个人理解对书中内容简要摘录（本笔记周更）</p>
<span id="more"></span>

<h2 id="Chapter-1-心理学充满生机（在科学阵营里表现不俗）"><a href="#Chapter-1-心理学充满生机（在科学阵营里表现不俗）" class="headerlink" title="Chapter 1. 心理学充满生机（在科学阵营里表现不俗）"></a>Chapter 1. 心理学充满生机（在科学阵营里表现不俗）</h2><h3 id="弗洛伊德的问题"><a href="#弗洛伊德的问题" class="headerlink" title="弗洛伊德的问题"></a>弗洛伊德的问题</h3><ul>
<li>弗洛伊德并不采用<strong>控制实验</strong>（控制实验是现代心理学家最有力的武器之一）</li>
<li>弗洛伊德认为“个案研究可以证明理论的真实或谬误”</li>
<li>弗洛伊德没有关注<strong>理论和行为数据之间的联系</strong>，他专注于构建复杂的理论架构，忽略了这些理论架构是否可以建立在可靠的、可重复的行为关系数据的基础上</li>
</ul>
<h3 id="现代心理学的多样性"><a href="#现代心理学的多样性" class="headerlink" title="现代心理学的多样性"></a>现代心理学的多样性</h3><ul>
<li>心理学分支众多，各行各业中都可以利用心理学（比如在数字图像处理中利用心理冗余）</li>
<li>心理学不是一个整合起来的宏大的理论，而是由许许多多用于解决某些特定行为的理论组织而成，<strong>理论的统一是一项极为困难的任务</strong>，但是<strong>并不是所有真正的科学都必须具备一个宏大而统一的理论</strong></li>
<li>美国的一些主要大学的心理学院系已经更名为“心理科学系（Department of Psychological Sciences）”，这表明<strong>无论学科内容多么多样，通过 科学 这一术语可以让我们找到统一性——即方法的统一而不是内容的统一</strong></li>
</ul>
<h3 id="科学的统一性"><a href="#科学的统一性" class="headerlink" title="科学的统一性"></a>科学的统一性</h3><ul>
<li>仅仅说心理学是“关于人类行为的科学”并不能将其与其他同样涉及研究人类行为的学科区分，比如经济学、社会学、人类学等，但是可以通过以下两点证明心理学是一门独立的学科：<br> ① 心理学<strong>采用科学方法</strong>来研究人类及动物的所有行为<br> ② 从这些研究结果发展而生的实际<strong>应用是基于科学</strong>的</li>
<li>心理学的首要特征是“<strong>基于数据的科学的行为研究</strong>”</li>
</ul>
<h3 id="什么是科学"><a href="#什么是科学" class="headerlink" title="什么是科学"></a>什么是科学</h3><ul>
<li>科学不是由研究的主题来定义的，对任何事物的研究都可以发展成一门科学</li>
<li>不能简单将宇宙万物划分为“科学的 OR 非科学的”</li>
<li><strong>科学是一种思考和观察宇宙万物以便深入理解其运行机制的方法</strong></li>
</ul>
<h3 id="科学的三个重要特征"><a href="#科学的三个重要特征" class="headerlink" title="科学的三个重要特征"></a>科学的三个重要特征</h3><ul>
<li>只是最重要的三个，<strong>科学方法并不是一套严格的规则，而是由一些非常普遍的原则所界定的</strong></li>
</ul>
<h4 id="①-系统实证主义的运用"><a href="#①-系统实证主义的运用" class="headerlink" title="① 系统实证主义的运用"></a>① 系统实证主义的运用</h4><ul>
<li>实证主义（empiricism）的意思是“依靠观察的做法”，但是<strong>纯粹的观察还不够</strong>，假设你记录下来一天从起床到睡觉之间的所有情况，当你完成时你会拥有一大堆事实，但是并不会对这个世界有更深的理解。因此我们需要<strong>系统地科学观察，结构化的观察结果能够解释自然世界一些潜在的本质</strong>。<strong>科学观察通常由理论驱动</strong>（比如在实验中常常通过一些误差指标衡量结果的优劣），他们检验对世界本质的不同解释，最后根据观察的结果，一些理论得到支持，而另一些则被拒绝</li>
</ul>
<h4 id="②-可公开验证的知识"><a href="#②-可公开验证的知识" class="headerlink" title="② 可公开验证的知识"></a>② 可公开验证的知识</h4><ul>
<li><strong>科学知识不是隶属于特定个体的思维过程</strong>，需要能够接受他人的审查和批评（同行评审），也就是说科学知识需要具有“<strong>可复现性</strong>”，<strong>科学拒绝只有某些特殊群体才能获得的特殊知识</strong></li>
<li>在科学中<strong>没有一个研究者是一座孤岛，每个研究者都与科学共同体及其知识库相联系</strong>。正是这种互相联系是的科学得以发展和积累，<strong>研究者不断在原有的知识的基础上进行新的探索，力求超越已知</strong></li>
<li><strong>并非所有通过“同行评审（peer review）”的学术期刊上的信息都是正确的，但是至少表明他已经达到了某些最低标准</strong>，大部分科学思想在满足一些基本标准的前提下，都能以正规文献的形式发表，因此<strong>存在所谓的“注水期刊”是很正常的，我们需要辨识文献的质量</strong></li>
</ul>
<h4 id="③-对可解决问题的检验"><a href="#③-对可解决问题的检验" class="headerlink" title="③ 对可解决问题的检验"></a>③ 对可解决问题的检验</h4><ul>
<li><strong>科学处理的是可解决的、可具体指明的问题</strong><br> “受过早教的儿童是否比没有接受早教的儿童更加聪明？”——科学问题<br> “人性本善还是本恶？生命的意义是什么？”——哲学问题</li>
<li>科学家致力于可实证解决的问题<strong>并不是说“问题在本质上可以分为可解决和不可解决的”，当前不可解决的问题，随着理论和实证方法更加先进会成为可解决的</strong>，比如在基因技术没有发展之前很难保证亲子鉴定的可靠性</li>
<li>  <strong>科学的进步过程</strong>：提出理论去解释世界中的特定现象，根据理论做出预测，实证这些预测，基于实证结果对理论进行修正（理论→预测→实证→修正）</li>
</ul>
<h3 id="心理学和世俗智慧"><a href="#心理学和世俗智慧" class="headerlink" title="心理学和世俗智慧"></a>心理学和世俗智慧</h3><ul>
<li><strong>每个人都有自己一套解释行为的内隐模型</strong>，并且影响我们的人际交往以及我们如何看待自己和他人，大多数人从来不会清晰且逻辑性地思考自己的这套理论，相反，通常只有在刻意关注或发现理论受到某种挑战时，才会意识到他们的存在</li>
<li>我们每个人的行为模型并没有内部一致性，当我们需要对某些行为作出解释时，往往搬出一些关于人类行为的普遍原理、说教等<strong>常识或者世俗智慧，这些往往是自相矛盾的</strong>，比如有人说“三思而后行”，就可以有人反驳“机不可失，时不再来”（杠精产生的因素？）</li>
<li>谚语和老话这类世俗智慧对人们有着极大的吸引力，因为他们合起来作为对行为的内隐“解释”，是难以被驳倒的。不论发生什么事，都可以搬出其中的一条辩解一番，<strong>难怪我们都认为自己是判断他人行为和人格的高手</strong>，从这种意义上说，世俗智慧是怯懦的，因为他不用冒着被驳倒的风险</li>
<li>世俗智慧就是“事后诸葛亮”，在真正的预测意义上是无用的，比如老师说“这次物理考试男生的平均成绩比女生的平均成绩高”，相信台下大多学生对此都不会怀疑，他们会觉得“男生的思维方式更加适合做物理题”，但实际上结果却是相反的，此时台下又可能觉得“女生比男生更加心细，更适合物理这种需要严谨推导的学科”。瞧，<strong>我们很容易就可以为完全相反的结果编造一个解释！</strong></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
